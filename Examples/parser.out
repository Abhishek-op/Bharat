Grammar:

Rule 0     S' -> program
Rule 1     program -> empty
Rule 2     program -> statements
Rule 3     statements -> statements statement
Rule 4     statements -> statement
Rule 5     statement -> expr SEP
Rule 6     statement -> var_assign SEP
Rule 7     statement -> LET var : var_type SEP
Rule 8     statement -> PRINT expr
Rule 9     statement -> var_define SEP
Rule 10    statement -> class_definition
Rule 11    statement -> struct_definition
Rule 12    statement -> if_statement
Rule 13    statement -> for_statement
Rule 14    statement -> while_statement
Rule 15    statement -> return_statement
Rule 16    statement -> function_definition
Rule 17    statement -> import_statement
Rule 18    statement -> RAW_INPUT
Rule 19    class_definition -> CLASS ID { function_definitions }
Rule 20    function_definitions -> function_definitions function_definition
Rule 21    function_definitions -> function_definition
Rule 22    function_definitions -> empty
Rule 23    struct_definition -> STRUCT ID { struct_fields } SEP
Rule 24    struct_fields -> struct_fields struct_field
Rule 25    struct_fields -> struct_field
Rule 26    struct_field -> LET ID : var_type SEP
Rule 27    var_type -> DICT_TYPE
Rule 28    var_type -> LIST_TYPE
Rule 29    var_type -> BOOL_TYPE
Rule 30    var_type -> STRING_TYPE
Rule 31    var_type -> FLOAT_TYPE
Rule 32    var_type -> INT_TYPE
Rule 33    import_statement -> IMPORT STRING SEP
Rule 34    function_definition -> FN ID ( params ) block
Rule 35    expr -> getter
Rule 36    expr -> { member_list }
Rule 37    expr -> NIL
Rule 38    expr -> var
Rule 39    expr -> var [ expr ]
Rule 40    expr -> list_val
Rule 41    expr -> FALSE
Rule 42    expr -> TRUE
Rule 43    expr -> STRING
Rule 44    expr -> FLOAT
Rule 45    expr -> INT
Rule 46    expr -> ( expr )
Rule 47    expr -> expr PERSENT expr
Rule 48    expr -> expr DIV expr
Rule 49    expr -> expr MUL expr
Rule 50    expr -> expr SUB expr
Rule 51    expr -> expr ADD expr
Rule 52    expr -> expr % expr  [precedence=left, level=11]
Rule 53    expr -> expr / expr  [precedence=left, level=11]
Rule 54    expr -> expr * expr  [precedence=left, level=11]
Rule 55    expr -> expr - expr  [precedence=left, level=10]
Rule 56    expr -> expr + expr  [precedence=left, level=10]
Rule 57    expr -> ! expr  [precedence=right, level=13]
Rule 58    expr -> + expr  [precedence=right, level=12]
Rule 59    expr -> - expr  [precedence=right, level=12]
Rule 60    expr -> ~ expr  [precedence=right, level=12]
Rule 61    expr -> expr | expr  [precedence=left, level=4]
Rule 62    expr -> expr ^ expr  [precedence=left, level=5]
Rule 63    expr -> expr & expr  [precedence=left, level=6]
Rule 64    expr -> expr SHR expr  [precedence=left, level=9]
Rule 65    expr -> expr SHL expr  [precedence=left, level=9]
Rule 66    expr -> expr GREATER expr  [precedence=left, level=8]
Rule 67    expr -> expr LESS expr  [precedence=left, level=8]
Rule 68    expr -> expr OR expr  [precedence=left, level=2]
Rule 69    expr -> expr AND expr  [precedence=left, level=3]
Rule 70    expr -> expr GREATEREQ expr  [precedence=left, level=8]
Rule 71    expr -> expr LESSEQ expr  [precedence=left, level=8]
Rule 72    expr -> expr NOTEQ expr  [precedence=left, level=7]
Rule 73    expr -> expr EQEQ expr  [precedence=left, level=7]
Rule 74    expr -> expr ID ( args )
Rule 75    expr -> ID DOUBLECOLON ID ( args )
Rule 76    expr -> ID ( args )
Rule 77    expr -> expr ? expr : expr
Rule 78    expr -> TYPEOF expr
Rule 79    expr -> LAMBDA ( params ) ARROW expr
Rule 80    expr -> ID LEFTARROW { struct_init_exprs }
Rule 81    struct_init_exprs -> struct_init_exprs , expr
Rule 82    struct_init_exprs -> expr
Rule 83    var_define -> LET getter ASSIGN expr
Rule 84    var_define -> LET var ASSIGN expr
Rule 85    return_statement -> RETURN expr SEP
Rule 86    var_assign -> DEC var  [precedence=right, level=12]
Rule 87    var_assign -> INC var  [precedence=right, level=12]
Rule 88    var_assign -> var SHRASGN expr  [precedence=right, level=1]
Rule 89    var_assign -> var SHLASGN expr  [precedence=right, level=1]
Rule 90    var_assign -> var XORASGN expr  [precedence=right, level=1]
Rule 91    var_assign -> var ORASGN expr  [precedence=right, level=1]
Rule 92    var_assign -> var ANDASGN expr  [precedence=right, level=1]
Rule 93    var_assign -> var MODULOASGN expr  [precedence=right, level=1]
Rule 94    var_assign -> var SLASHASGN expr  [precedence=right, level=1]
Rule 95    var_assign -> var STARASGN expr  [precedence=right, level=1]
Rule 96    var_assign -> var MINUSASGN expr  [precedence=right, level=1]
Rule 97    var_assign -> var PLUSASGN expr  [precedence=right, level=1]
Rule 98    var_assign -> var ASSIGN RAW_INPUT
Rule 99    var_assign -> var ASSIGN expr
Rule 100   if_statement -> IF expr block
Rule 101   if_statement -> IF expr block ELSE block
Rule 102   while_statement -> WHILE expr block
Rule 103   for_statement -> FOR expr TO expr block
Rule 104   list_val -> [ exprs ]
Rule 105   exprs -> exprs , expr
Rule 106   exprs -> expr
Rule 107   exprs -> empty
Rule 108   var -> var [ expr ]
Rule 109   var -> ID
Rule 110   empty -> <empty>
Rule 111   block -> statement
Rule 112   block -> { program }
Rule 113   params -> empty
Rule 114   params -> param
Rule 115   params -> params , param
Rule 116   param -> ID var_type
Rule 117   args -> empty
Rule 118   args -> arg
Rule 119   args -> args , arg
Rule 120   arg -> expr
Rule 121   member_list -> member_list , member
Rule 122   member_list -> member
Rule 123   member_list -> empty
Rule 124   member -> STRING : expr
Rule 125   getter -> ID
Rule 126   getter -> getter . ID

Unused terminals:

    PIPE

Terminals, with rules where they appear:

!                    : 57
%                    : 52
&                    : 63
(                    : 34 46 74 75 76 79
)                    : 34 46 74 75 76 79
*                    : 54
+                    : 56 58
,                    : 81 105 115 119 121
-                    : 55 59
.                    : 126
/                    : 53
:                    : 7 26 77 124
?                    : 77
ADD                  : 51
AND                  : 69
ANDASGN              : 92
ARROW                : 79
ASSIGN               : 83 84 98 99
BOOL_TYPE            : 29
CLASS                : 19
DEC                  : 86
DICT_TYPE            : 27
DIV                  : 48
DOUBLECOLON          : 75
ELSE                 : 101
EQEQ                 : 73
FALSE                : 41
FLOAT                : 44
FLOAT_TYPE           : 31
FN                   : 34
FOR                  : 103
GREATER              : 66
GREATEREQ            : 70
ID                   : 19 23 26 34 74 75 75 76 80 109 116 125 126
IF                   : 100 101
IMPORT               : 33
INC                  : 87
INT                  : 45
INT_TYPE             : 32
LAMBDA               : 79
LEFTARROW            : 80
LESS                 : 67
LESSEQ               : 71
LET                  : 7 26 83 84
LIST_TYPE            : 28
MINUSASGN            : 96
MODULOASGN           : 93
MUL                  : 49
NIL                  : 37
NOTEQ                : 72
OR                   : 68
ORASGN               : 91
PERSENT              : 47
PIPE                 : 
PLUSASGN             : 97
PRINT                : 8
RAW_INPUT            : 18 98
RETURN               : 85
SEP                  : 5 6 7 9 23 26 33 85
SHL                  : 65
SHLASGN              : 89
SHR                  : 64
SHRASGN              : 88
SLASHASGN            : 94
STARASGN             : 95
STRING               : 33 43 124
STRING_TYPE          : 30
STRUCT               : 23
SUB                  : 50
TO                   : 103
TRUE                 : 42
TYPEOF               : 78
WHILE                : 102
XORASGN              : 90
[                    : 39 104 108
]                    : 39 104 108
^                    : 62
error                : 
{                    : 19 23 36 80 112
|                    : 61
}                    : 19 23 36 80 112
~                    : 60

Nonterminals, with rules where they appear:

arg                  : 118 119
args                 : 74 75 76 119
block                : 34 100 101 101 102 103
class_definition     : 10
empty                : 1 22 107 113 117 123
expr                 : 5 8 39 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 58 59 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 77 77 77 78 79 81 82 83 84 85 88 89 90 91 92 93 94 95 96 97 99 100 101 102 103 103 105 106 108 120 124
exprs                : 104 105
for_statement        : 13
function_definition  : 16 20 21
function_definitions : 19 20
getter               : 35 83 126
if_statement         : 12
import_statement     : 17
list_val             : 40
member               : 121 122
member_list          : 36 121
param                : 114 115
params               : 34 79 115
program              : 112 0
return_statement     : 15
statement            : 3 4 111
statements           : 2 3
struct_definition    : 11
struct_field         : 24 25
struct_fields        : 23 24
struct_init_exprs    : 80 81
var                  : 7 38 39 84 86 87 88 89 90 91 92 93 94 95 96 97 98 99 108
var_assign           : 6
var_define           : 9
var_type             : 7 26 116
while_statement      : 14


state 0

    (0) S' -> . program
    (1) program -> . empty
    (2) program -> . statements
    (110) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    $end            reduce using rule 110 (empty -> .)
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    program                        shift and go to state 1
    empty                          shift and go to state 2
    statements                     shift and go to state 3
    statement                      shift and go to state 4
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 1

    (0) S' -> program .


state 2

    (1) program -> empty .
    $end            reduce using rule 1 (program -> empty .)


state 3

    (2) program -> statements .
    (3) statements -> statements . statement
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    $end            reduce using rule 2 (program -> statements .)
    }               reduce using rule 2 (program -> statements .)
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    statement                      shift and go to state 48
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 4

    (4) statements -> statement .
    LET             reduce using rule 4 (statements -> statement .)
    PRINT           reduce using rule 4 (statements -> statement .)
    RAW_INPUT       reduce using rule 4 (statements -> statement .)
    {               reduce using rule 4 (statements -> statement .)
    NIL             reduce using rule 4 (statements -> statement .)
    FALSE           reduce using rule 4 (statements -> statement .)
    TRUE            reduce using rule 4 (statements -> statement .)
    STRING          reduce using rule 4 (statements -> statement .)
    FLOAT           reduce using rule 4 (statements -> statement .)
    INT             reduce using rule 4 (statements -> statement .)
    (               reduce using rule 4 (statements -> statement .)
    !               reduce using rule 4 (statements -> statement .)
    +               reduce using rule 4 (statements -> statement .)
    -               reduce using rule 4 (statements -> statement .)
    ~               reduce using rule 4 (statements -> statement .)
    ID              reduce using rule 4 (statements -> statement .)
    TYPEOF          reduce using rule 4 (statements -> statement .)
    LAMBDA          reduce using rule 4 (statements -> statement .)
    DEC             reduce using rule 4 (statements -> statement .)
    INC             reduce using rule 4 (statements -> statement .)
    CLASS           reduce using rule 4 (statements -> statement .)
    STRUCT          reduce using rule 4 (statements -> statement .)
    IF              reduce using rule 4 (statements -> statement .)
    FOR             reduce using rule 4 (statements -> statement .)
    WHILE           reduce using rule 4 (statements -> statement .)
    RETURN          reduce using rule 4 (statements -> statement .)
    FN              reduce using rule 4 (statements -> statement .)
    IMPORT          reduce using rule 4 (statements -> statement .)
    [               reduce using rule 4 (statements -> statement .)
    $end            reduce using rule 4 (statements -> statement .)
    }               reduce using rule 4 (statements -> statement .)


state 5

    (5) statement -> expr . SEP
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             shift and go to state 49
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 6

    (6) statement -> var_assign . SEP
    SEP             shift and go to state 75


state 7

    (7) statement -> LET . var : var_type SEP
    (83) var_define -> LET . getter ASSIGN expr
    (84) var_define -> LET . var ASSIGN expr
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (125) getter -> . ID
    (126) getter -> . getter . ID
    ID              shift and go to state 78

    var                            shift and go to state 76
    getter                         shift and go to state 77

state 8

    (38) expr -> var .
    (39) expr -> var . [ expr ]
    (88) var_assign -> var . SHRASGN expr
    (89) var_assign -> var . SHLASGN expr
    (90) var_assign -> var . XORASGN expr
    (91) var_assign -> var . ORASGN expr
    (92) var_assign -> var . ANDASGN expr
    (93) var_assign -> var . MODULOASGN expr
    (94) var_assign -> var . SLASHASGN expr
    (95) var_assign -> var . STARASGN expr
    (96) var_assign -> var . MINUSASGN expr
    (97) var_assign -> var . PLUSASGN expr
    (98) var_assign -> var . ASSIGN RAW_INPUT
    (99) var_assign -> var . ASSIGN expr
    (108) var -> var . [ expr ]
    SEP             reduce using rule 38 (expr -> var .)
    PERSENT         reduce using rule 38 (expr -> var .)
    DIV             reduce using rule 38 (expr -> var .)
    MUL             reduce using rule 38 (expr -> var .)
    SUB             reduce using rule 38 (expr -> var .)
    ADD             reduce using rule 38 (expr -> var .)
    %               reduce using rule 38 (expr -> var .)
    /               reduce using rule 38 (expr -> var .)
    *               reduce using rule 38 (expr -> var .)
    -               reduce using rule 38 (expr -> var .)
    +               reduce using rule 38 (expr -> var .)
    |               reduce using rule 38 (expr -> var .)
    ^               reduce using rule 38 (expr -> var .)
    &               reduce using rule 38 (expr -> var .)
    SHR             reduce using rule 38 (expr -> var .)
    SHL             reduce using rule 38 (expr -> var .)
    GREATER         reduce using rule 38 (expr -> var .)
    LESS            reduce using rule 38 (expr -> var .)
    OR              reduce using rule 38 (expr -> var .)
    AND             reduce using rule 38 (expr -> var .)
    GREATEREQ       reduce using rule 38 (expr -> var .)
    LESSEQ          reduce using rule 38 (expr -> var .)
    NOTEQ           reduce using rule 38 (expr -> var .)
    EQEQ            reduce using rule 38 (expr -> var .)
    ID              reduce using rule 38 (expr -> var .)
    ?               reduce using rule 38 (expr -> var .)
    [               shift and go to state 79
    SHRASGN         shift and go to state 80
    SHLASGN         shift and go to state 81
    XORASGN         shift and go to state 82
    ORASGN          shift and go to state 83
    ANDASGN         shift and go to state 84
    MODULOASGN      shift and go to state 85
    SLASHASGN       shift and go to state 86
    STARASGN        shift and go to state 87
    MINUSASGN       shift and go to state 88
    PLUSASGN        shift and go to state 89
    ASSIGN          shift and go to state 90


state 9

    (8) statement -> PRINT . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 91
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 10

    (9) statement -> var_define . SEP
    SEP             shift and go to state 93


state 11

    (10) statement -> class_definition .
    LET             reduce using rule 10 (statement -> class_definition .)
    PRINT           reduce using rule 10 (statement -> class_definition .)
    RAW_INPUT       reduce using rule 10 (statement -> class_definition .)
    {               reduce using rule 10 (statement -> class_definition .)
    NIL             reduce using rule 10 (statement -> class_definition .)
    FALSE           reduce using rule 10 (statement -> class_definition .)
    TRUE            reduce using rule 10 (statement -> class_definition .)
    STRING          reduce using rule 10 (statement -> class_definition .)
    FLOAT           reduce using rule 10 (statement -> class_definition .)
    INT             reduce using rule 10 (statement -> class_definition .)
    (               reduce using rule 10 (statement -> class_definition .)
    !               reduce using rule 10 (statement -> class_definition .)
    +               reduce using rule 10 (statement -> class_definition .)
    -               reduce using rule 10 (statement -> class_definition .)
    ~               reduce using rule 10 (statement -> class_definition .)
    ID              reduce using rule 10 (statement -> class_definition .)
    TYPEOF          reduce using rule 10 (statement -> class_definition .)
    LAMBDA          reduce using rule 10 (statement -> class_definition .)
    DEC             reduce using rule 10 (statement -> class_definition .)
    INC             reduce using rule 10 (statement -> class_definition .)
    CLASS           reduce using rule 10 (statement -> class_definition .)
    STRUCT          reduce using rule 10 (statement -> class_definition .)
    IF              reduce using rule 10 (statement -> class_definition .)
    FOR             reduce using rule 10 (statement -> class_definition .)
    WHILE           reduce using rule 10 (statement -> class_definition .)
    RETURN          reduce using rule 10 (statement -> class_definition .)
    FN              reduce using rule 10 (statement -> class_definition .)
    IMPORT          reduce using rule 10 (statement -> class_definition .)
    [               reduce using rule 10 (statement -> class_definition .)
    $end            reduce using rule 10 (statement -> class_definition .)
    }               reduce using rule 10 (statement -> class_definition .)
    ELSE            reduce using rule 10 (statement -> class_definition .)


state 12

    (11) statement -> struct_definition .
    LET             reduce using rule 11 (statement -> struct_definition .)
    PRINT           reduce using rule 11 (statement -> struct_definition .)
    RAW_INPUT       reduce using rule 11 (statement -> struct_definition .)
    {               reduce using rule 11 (statement -> struct_definition .)
    NIL             reduce using rule 11 (statement -> struct_definition .)
    FALSE           reduce using rule 11 (statement -> struct_definition .)
    TRUE            reduce using rule 11 (statement -> struct_definition .)
    STRING          reduce using rule 11 (statement -> struct_definition .)
    FLOAT           reduce using rule 11 (statement -> struct_definition .)
    INT             reduce using rule 11 (statement -> struct_definition .)
    (               reduce using rule 11 (statement -> struct_definition .)
    !               reduce using rule 11 (statement -> struct_definition .)
    +               reduce using rule 11 (statement -> struct_definition .)
    -               reduce using rule 11 (statement -> struct_definition .)
    ~               reduce using rule 11 (statement -> struct_definition .)
    ID              reduce using rule 11 (statement -> struct_definition .)
    TYPEOF          reduce using rule 11 (statement -> struct_definition .)
    LAMBDA          reduce using rule 11 (statement -> struct_definition .)
    DEC             reduce using rule 11 (statement -> struct_definition .)
    INC             reduce using rule 11 (statement -> struct_definition .)
    CLASS           reduce using rule 11 (statement -> struct_definition .)
    STRUCT          reduce using rule 11 (statement -> struct_definition .)
    IF              reduce using rule 11 (statement -> struct_definition .)
    FOR             reduce using rule 11 (statement -> struct_definition .)
    WHILE           reduce using rule 11 (statement -> struct_definition .)
    RETURN          reduce using rule 11 (statement -> struct_definition .)
    FN              reduce using rule 11 (statement -> struct_definition .)
    IMPORT          reduce using rule 11 (statement -> struct_definition .)
    [               reduce using rule 11 (statement -> struct_definition .)
    $end            reduce using rule 11 (statement -> struct_definition .)
    }               reduce using rule 11 (statement -> struct_definition .)
    ELSE            reduce using rule 11 (statement -> struct_definition .)


state 13

    (12) statement -> if_statement .
    LET             reduce using rule 12 (statement -> if_statement .)
    PRINT           reduce using rule 12 (statement -> if_statement .)
    RAW_INPUT       reduce using rule 12 (statement -> if_statement .)
    {               reduce using rule 12 (statement -> if_statement .)
    NIL             reduce using rule 12 (statement -> if_statement .)
    FALSE           reduce using rule 12 (statement -> if_statement .)
    TRUE            reduce using rule 12 (statement -> if_statement .)
    STRING          reduce using rule 12 (statement -> if_statement .)
    FLOAT           reduce using rule 12 (statement -> if_statement .)
    INT             reduce using rule 12 (statement -> if_statement .)
    (               reduce using rule 12 (statement -> if_statement .)
    !               reduce using rule 12 (statement -> if_statement .)
    +               reduce using rule 12 (statement -> if_statement .)
    -               reduce using rule 12 (statement -> if_statement .)
    ~               reduce using rule 12 (statement -> if_statement .)
    ID              reduce using rule 12 (statement -> if_statement .)
    TYPEOF          reduce using rule 12 (statement -> if_statement .)
    LAMBDA          reduce using rule 12 (statement -> if_statement .)
    DEC             reduce using rule 12 (statement -> if_statement .)
    INC             reduce using rule 12 (statement -> if_statement .)
    CLASS           reduce using rule 12 (statement -> if_statement .)
    STRUCT          reduce using rule 12 (statement -> if_statement .)
    IF              reduce using rule 12 (statement -> if_statement .)
    FOR             reduce using rule 12 (statement -> if_statement .)
    WHILE           reduce using rule 12 (statement -> if_statement .)
    RETURN          reduce using rule 12 (statement -> if_statement .)
    FN              reduce using rule 12 (statement -> if_statement .)
    IMPORT          reduce using rule 12 (statement -> if_statement .)
    [               reduce using rule 12 (statement -> if_statement .)
    $end            reduce using rule 12 (statement -> if_statement .)
    }               reduce using rule 12 (statement -> if_statement .)
    ELSE            reduce using rule 12 (statement -> if_statement .)


state 14

    (13) statement -> for_statement .
    LET             reduce using rule 13 (statement -> for_statement .)
    PRINT           reduce using rule 13 (statement -> for_statement .)
    RAW_INPUT       reduce using rule 13 (statement -> for_statement .)
    {               reduce using rule 13 (statement -> for_statement .)
    NIL             reduce using rule 13 (statement -> for_statement .)
    FALSE           reduce using rule 13 (statement -> for_statement .)
    TRUE            reduce using rule 13 (statement -> for_statement .)
    STRING          reduce using rule 13 (statement -> for_statement .)
    FLOAT           reduce using rule 13 (statement -> for_statement .)
    INT             reduce using rule 13 (statement -> for_statement .)
    (               reduce using rule 13 (statement -> for_statement .)
    !               reduce using rule 13 (statement -> for_statement .)
    +               reduce using rule 13 (statement -> for_statement .)
    -               reduce using rule 13 (statement -> for_statement .)
    ~               reduce using rule 13 (statement -> for_statement .)
    ID              reduce using rule 13 (statement -> for_statement .)
    TYPEOF          reduce using rule 13 (statement -> for_statement .)
    LAMBDA          reduce using rule 13 (statement -> for_statement .)
    DEC             reduce using rule 13 (statement -> for_statement .)
    INC             reduce using rule 13 (statement -> for_statement .)
    CLASS           reduce using rule 13 (statement -> for_statement .)
    STRUCT          reduce using rule 13 (statement -> for_statement .)
    IF              reduce using rule 13 (statement -> for_statement .)
    FOR             reduce using rule 13 (statement -> for_statement .)
    WHILE           reduce using rule 13 (statement -> for_statement .)
    RETURN          reduce using rule 13 (statement -> for_statement .)
    FN              reduce using rule 13 (statement -> for_statement .)
    IMPORT          reduce using rule 13 (statement -> for_statement .)
    [               reduce using rule 13 (statement -> for_statement .)
    $end            reduce using rule 13 (statement -> for_statement .)
    }               reduce using rule 13 (statement -> for_statement .)
    ELSE            reduce using rule 13 (statement -> for_statement .)


state 15

    (14) statement -> while_statement .
    LET             reduce using rule 14 (statement -> while_statement .)
    PRINT           reduce using rule 14 (statement -> while_statement .)
    RAW_INPUT       reduce using rule 14 (statement -> while_statement .)
    {               reduce using rule 14 (statement -> while_statement .)
    NIL             reduce using rule 14 (statement -> while_statement .)
    FALSE           reduce using rule 14 (statement -> while_statement .)
    TRUE            reduce using rule 14 (statement -> while_statement .)
    STRING          reduce using rule 14 (statement -> while_statement .)
    FLOAT           reduce using rule 14 (statement -> while_statement .)
    INT             reduce using rule 14 (statement -> while_statement .)
    (               reduce using rule 14 (statement -> while_statement .)
    !               reduce using rule 14 (statement -> while_statement .)
    +               reduce using rule 14 (statement -> while_statement .)
    -               reduce using rule 14 (statement -> while_statement .)
    ~               reduce using rule 14 (statement -> while_statement .)
    ID              reduce using rule 14 (statement -> while_statement .)
    TYPEOF          reduce using rule 14 (statement -> while_statement .)
    LAMBDA          reduce using rule 14 (statement -> while_statement .)
    DEC             reduce using rule 14 (statement -> while_statement .)
    INC             reduce using rule 14 (statement -> while_statement .)
    CLASS           reduce using rule 14 (statement -> while_statement .)
    STRUCT          reduce using rule 14 (statement -> while_statement .)
    IF              reduce using rule 14 (statement -> while_statement .)
    FOR             reduce using rule 14 (statement -> while_statement .)
    WHILE           reduce using rule 14 (statement -> while_statement .)
    RETURN          reduce using rule 14 (statement -> while_statement .)
    FN              reduce using rule 14 (statement -> while_statement .)
    IMPORT          reduce using rule 14 (statement -> while_statement .)
    [               reduce using rule 14 (statement -> while_statement .)
    $end            reduce using rule 14 (statement -> while_statement .)
    }               reduce using rule 14 (statement -> while_statement .)
    ELSE            reduce using rule 14 (statement -> while_statement .)


state 16

    (15) statement -> return_statement .
    LET             reduce using rule 15 (statement -> return_statement .)
    PRINT           reduce using rule 15 (statement -> return_statement .)
    RAW_INPUT       reduce using rule 15 (statement -> return_statement .)
    {               reduce using rule 15 (statement -> return_statement .)
    NIL             reduce using rule 15 (statement -> return_statement .)
    FALSE           reduce using rule 15 (statement -> return_statement .)
    TRUE            reduce using rule 15 (statement -> return_statement .)
    STRING          reduce using rule 15 (statement -> return_statement .)
    FLOAT           reduce using rule 15 (statement -> return_statement .)
    INT             reduce using rule 15 (statement -> return_statement .)
    (               reduce using rule 15 (statement -> return_statement .)
    !               reduce using rule 15 (statement -> return_statement .)
    +               reduce using rule 15 (statement -> return_statement .)
    -               reduce using rule 15 (statement -> return_statement .)
    ~               reduce using rule 15 (statement -> return_statement .)
    ID              reduce using rule 15 (statement -> return_statement .)
    TYPEOF          reduce using rule 15 (statement -> return_statement .)
    LAMBDA          reduce using rule 15 (statement -> return_statement .)
    DEC             reduce using rule 15 (statement -> return_statement .)
    INC             reduce using rule 15 (statement -> return_statement .)
    CLASS           reduce using rule 15 (statement -> return_statement .)
    STRUCT          reduce using rule 15 (statement -> return_statement .)
    IF              reduce using rule 15 (statement -> return_statement .)
    FOR             reduce using rule 15 (statement -> return_statement .)
    WHILE           reduce using rule 15 (statement -> return_statement .)
    RETURN          reduce using rule 15 (statement -> return_statement .)
    FN              reduce using rule 15 (statement -> return_statement .)
    IMPORT          reduce using rule 15 (statement -> return_statement .)
    [               reduce using rule 15 (statement -> return_statement .)
    $end            reduce using rule 15 (statement -> return_statement .)
    }               reduce using rule 15 (statement -> return_statement .)
    ELSE            reduce using rule 15 (statement -> return_statement .)


state 17

    (16) statement -> function_definition .
    LET             reduce using rule 16 (statement -> function_definition .)
    PRINT           reduce using rule 16 (statement -> function_definition .)
    RAW_INPUT       reduce using rule 16 (statement -> function_definition .)
    {               reduce using rule 16 (statement -> function_definition .)
    NIL             reduce using rule 16 (statement -> function_definition .)
    FALSE           reduce using rule 16 (statement -> function_definition .)
    TRUE            reduce using rule 16 (statement -> function_definition .)
    STRING          reduce using rule 16 (statement -> function_definition .)
    FLOAT           reduce using rule 16 (statement -> function_definition .)
    INT             reduce using rule 16 (statement -> function_definition .)
    (               reduce using rule 16 (statement -> function_definition .)
    !               reduce using rule 16 (statement -> function_definition .)
    +               reduce using rule 16 (statement -> function_definition .)
    -               reduce using rule 16 (statement -> function_definition .)
    ~               reduce using rule 16 (statement -> function_definition .)
    ID              reduce using rule 16 (statement -> function_definition .)
    TYPEOF          reduce using rule 16 (statement -> function_definition .)
    LAMBDA          reduce using rule 16 (statement -> function_definition .)
    DEC             reduce using rule 16 (statement -> function_definition .)
    INC             reduce using rule 16 (statement -> function_definition .)
    CLASS           reduce using rule 16 (statement -> function_definition .)
    STRUCT          reduce using rule 16 (statement -> function_definition .)
    IF              reduce using rule 16 (statement -> function_definition .)
    FOR             reduce using rule 16 (statement -> function_definition .)
    WHILE           reduce using rule 16 (statement -> function_definition .)
    RETURN          reduce using rule 16 (statement -> function_definition .)
    FN              reduce using rule 16 (statement -> function_definition .)
    IMPORT          reduce using rule 16 (statement -> function_definition .)
    [               reduce using rule 16 (statement -> function_definition .)
    $end            reduce using rule 16 (statement -> function_definition .)
    }               reduce using rule 16 (statement -> function_definition .)
    ELSE            reduce using rule 16 (statement -> function_definition .)


state 18

    (17) statement -> import_statement .
    LET             reduce using rule 17 (statement -> import_statement .)
    PRINT           reduce using rule 17 (statement -> import_statement .)
    RAW_INPUT       reduce using rule 17 (statement -> import_statement .)
    {               reduce using rule 17 (statement -> import_statement .)
    NIL             reduce using rule 17 (statement -> import_statement .)
    FALSE           reduce using rule 17 (statement -> import_statement .)
    TRUE            reduce using rule 17 (statement -> import_statement .)
    STRING          reduce using rule 17 (statement -> import_statement .)
    FLOAT           reduce using rule 17 (statement -> import_statement .)
    INT             reduce using rule 17 (statement -> import_statement .)
    (               reduce using rule 17 (statement -> import_statement .)
    !               reduce using rule 17 (statement -> import_statement .)
    +               reduce using rule 17 (statement -> import_statement .)
    -               reduce using rule 17 (statement -> import_statement .)
    ~               reduce using rule 17 (statement -> import_statement .)
    ID              reduce using rule 17 (statement -> import_statement .)
    TYPEOF          reduce using rule 17 (statement -> import_statement .)
    LAMBDA          reduce using rule 17 (statement -> import_statement .)
    DEC             reduce using rule 17 (statement -> import_statement .)
    INC             reduce using rule 17 (statement -> import_statement .)
    CLASS           reduce using rule 17 (statement -> import_statement .)
    STRUCT          reduce using rule 17 (statement -> import_statement .)
    IF              reduce using rule 17 (statement -> import_statement .)
    FOR             reduce using rule 17 (statement -> import_statement .)
    WHILE           reduce using rule 17 (statement -> import_statement .)
    RETURN          reduce using rule 17 (statement -> import_statement .)
    FN              reduce using rule 17 (statement -> import_statement .)
    IMPORT          reduce using rule 17 (statement -> import_statement .)
    [               reduce using rule 17 (statement -> import_statement .)
    $end            reduce using rule 17 (statement -> import_statement .)
    }               reduce using rule 17 (statement -> import_statement .)
    ELSE            reduce using rule 17 (statement -> import_statement .)


state 19

    (18) statement -> RAW_INPUT .
    LET             reduce using rule 18 (statement -> RAW_INPUT .)
    PRINT           reduce using rule 18 (statement -> RAW_INPUT .)
    RAW_INPUT       reduce using rule 18 (statement -> RAW_INPUT .)
    {               reduce using rule 18 (statement -> RAW_INPUT .)
    NIL             reduce using rule 18 (statement -> RAW_INPUT .)
    FALSE           reduce using rule 18 (statement -> RAW_INPUT .)
    TRUE            reduce using rule 18 (statement -> RAW_INPUT .)
    STRING          reduce using rule 18 (statement -> RAW_INPUT .)
    FLOAT           reduce using rule 18 (statement -> RAW_INPUT .)
    INT             reduce using rule 18 (statement -> RAW_INPUT .)
    (               reduce using rule 18 (statement -> RAW_INPUT .)
    !               reduce using rule 18 (statement -> RAW_INPUT .)
    +               reduce using rule 18 (statement -> RAW_INPUT .)
    -               reduce using rule 18 (statement -> RAW_INPUT .)
    ~               reduce using rule 18 (statement -> RAW_INPUT .)
    ID              reduce using rule 18 (statement -> RAW_INPUT .)
    TYPEOF          reduce using rule 18 (statement -> RAW_INPUT .)
    LAMBDA          reduce using rule 18 (statement -> RAW_INPUT .)
    DEC             reduce using rule 18 (statement -> RAW_INPUT .)
    INC             reduce using rule 18 (statement -> RAW_INPUT .)
    CLASS           reduce using rule 18 (statement -> RAW_INPUT .)
    STRUCT          reduce using rule 18 (statement -> RAW_INPUT .)
    IF              reduce using rule 18 (statement -> RAW_INPUT .)
    FOR             reduce using rule 18 (statement -> RAW_INPUT .)
    WHILE           reduce using rule 18 (statement -> RAW_INPUT .)
    RETURN          reduce using rule 18 (statement -> RAW_INPUT .)
    FN              reduce using rule 18 (statement -> RAW_INPUT .)
    IMPORT          reduce using rule 18 (statement -> RAW_INPUT .)
    [               reduce using rule 18 (statement -> RAW_INPUT .)
    $end            reduce using rule 18 (statement -> RAW_INPUT .)
    }               reduce using rule 18 (statement -> RAW_INPUT .)
    ELSE            reduce using rule 18 (statement -> RAW_INPUT .)


state 20

    (35) expr -> getter .
    (126) getter -> getter . . ID
    SEP             reduce using rule 35 (expr -> getter .)
    PERSENT         reduce using rule 35 (expr -> getter .)
    DIV             reduce using rule 35 (expr -> getter .)
    MUL             reduce using rule 35 (expr -> getter .)
    SUB             reduce using rule 35 (expr -> getter .)
    ADD             reduce using rule 35 (expr -> getter .)
    %               reduce using rule 35 (expr -> getter .)
    /               reduce using rule 35 (expr -> getter .)
    *               reduce using rule 35 (expr -> getter .)
    -               reduce using rule 35 (expr -> getter .)
    +               reduce using rule 35 (expr -> getter .)
    |               reduce using rule 35 (expr -> getter .)
    ^               reduce using rule 35 (expr -> getter .)
    &               reduce using rule 35 (expr -> getter .)
    SHR             reduce using rule 35 (expr -> getter .)
    SHL             reduce using rule 35 (expr -> getter .)
    GREATER         reduce using rule 35 (expr -> getter .)
    LESS            reduce using rule 35 (expr -> getter .)
    OR              reduce using rule 35 (expr -> getter .)
    AND             reduce using rule 35 (expr -> getter .)
    GREATEREQ       reduce using rule 35 (expr -> getter .)
    LESSEQ          reduce using rule 35 (expr -> getter .)
    NOTEQ           reduce using rule 35 (expr -> getter .)
    EQEQ            reduce using rule 35 (expr -> getter .)
    ID              reduce using rule 35 (expr -> getter .)
    ?               reduce using rule 35 (expr -> getter .)
    LET             reduce using rule 35 (expr -> getter .)
    PRINT           reduce using rule 35 (expr -> getter .)
    RAW_INPUT       reduce using rule 35 (expr -> getter .)
    {               reduce using rule 35 (expr -> getter .)
    NIL             reduce using rule 35 (expr -> getter .)
    FALSE           reduce using rule 35 (expr -> getter .)
    TRUE            reduce using rule 35 (expr -> getter .)
    STRING          reduce using rule 35 (expr -> getter .)
    FLOAT           reduce using rule 35 (expr -> getter .)
    INT             reduce using rule 35 (expr -> getter .)
    (               reduce using rule 35 (expr -> getter .)
    !               reduce using rule 35 (expr -> getter .)
    ~               reduce using rule 35 (expr -> getter .)
    TYPEOF          reduce using rule 35 (expr -> getter .)
    LAMBDA          reduce using rule 35 (expr -> getter .)
    DEC             reduce using rule 35 (expr -> getter .)
    INC             reduce using rule 35 (expr -> getter .)
    CLASS           reduce using rule 35 (expr -> getter .)
    STRUCT          reduce using rule 35 (expr -> getter .)
    IF              reduce using rule 35 (expr -> getter .)
    FOR             reduce using rule 35 (expr -> getter .)
    WHILE           reduce using rule 35 (expr -> getter .)
    RETURN          reduce using rule 35 (expr -> getter .)
    FN              reduce using rule 35 (expr -> getter .)
    IMPORT          reduce using rule 35 (expr -> getter .)
    [               reduce using rule 35 (expr -> getter .)
    $end            reduce using rule 35 (expr -> getter .)
    }               reduce using rule 35 (expr -> getter .)
    ELSE            reduce using rule 35 (expr -> getter .)
    ]               reduce using rule 35 (expr -> getter .)
    ,               reduce using rule 35 (expr -> getter .)
    )               reduce using rule 35 (expr -> getter .)
    TO              reduce using rule 35 (expr -> getter .)
    :               reduce using rule 35 (expr -> getter .)
    .               shift and go to state 94


state 21

    (36) expr -> { . member_list }
    (121) member_list -> . member_list , member
    (122) member_list -> . member
    (123) member_list -> . empty
    (124) member -> . STRING : expr
    (110) empty -> .
    STRING          shift and go to state 98
    }               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)

    member_list                    shift and go to state 95
    member                         shift and go to state 96
    empty                          shift and go to state 97

state 22

    (37) expr -> NIL .
    SEP             reduce using rule 37 (expr -> NIL .)
    PERSENT         reduce using rule 37 (expr -> NIL .)
    DIV             reduce using rule 37 (expr -> NIL .)
    MUL             reduce using rule 37 (expr -> NIL .)
    SUB             reduce using rule 37 (expr -> NIL .)
    ADD             reduce using rule 37 (expr -> NIL .)
    %               reduce using rule 37 (expr -> NIL .)
    /               reduce using rule 37 (expr -> NIL .)
    *               reduce using rule 37 (expr -> NIL .)
    -               reduce using rule 37 (expr -> NIL .)
    +               reduce using rule 37 (expr -> NIL .)
    |               reduce using rule 37 (expr -> NIL .)
    ^               reduce using rule 37 (expr -> NIL .)
    &               reduce using rule 37 (expr -> NIL .)
    SHR             reduce using rule 37 (expr -> NIL .)
    SHL             reduce using rule 37 (expr -> NIL .)
    GREATER         reduce using rule 37 (expr -> NIL .)
    LESS            reduce using rule 37 (expr -> NIL .)
    OR              reduce using rule 37 (expr -> NIL .)
    AND             reduce using rule 37 (expr -> NIL .)
    GREATEREQ       reduce using rule 37 (expr -> NIL .)
    LESSEQ          reduce using rule 37 (expr -> NIL .)
    NOTEQ           reduce using rule 37 (expr -> NIL .)
    EQEQ            reduce using rule 37 (expr -> NIL .)
    ID              reduce using rule 37 (expr -> NIL .)
    ?               reduce using rule 37 (expr -> NIL .)
    LET             reduce using rule 37 (expr -> NIL .)
    PRINT           reduce using rule 37 (expr -> NIL .)
    RAW_INPUT       reduce using rule 37 (expr -> NIL .)
    {               reduce using rule 37 (expr -> NIL .)
    NIL             reduce using rule 37 (expr -> NIL .)
    FALSE           reduce using rule 37 (expr -> NIL .)
    TRUE            reduce using rule 37 (expr -> NIL .)
    STRING          reduce using rule 37 (expr -> NIL .)
    FLOAT           reduce using rule 37 (expr -> NIL .)
    INT             reduce using rule 37 (expr -> NIL .)
    (               reduce using rule 37 (expr -> NIL .)
    !               reduce using rule 37 (expr -> NIL .)
    ~               reduce using rule 37 (expr -> NIL .)
    TYPEOF          reduce using rule 37 (expr -> NIL .)
    LAMBDA          reduce using rule 37 (expr -> NIL .)
    DEC             reduce using rule 37 (expr -> NIL .)
    INC             reduce using rule 37 (expr -> NIL .)
    CLASS           reduce using rule 37 (expr -> NIL .)
    STRUCT          reduce using rule 37 (expr -> NIL .)
    IF              reduce using rule 37 (expr -> NIL .)
    FOR             reduce using rule 37 (expr -> NIL .)
    WHILE           reduce using rule 37 (expr -> NIL .)
    RETURN          reduce using rule 37 (expr -> NIL .)
    FN              reduce using rule 37 (expr -> NIL .)
    IMPORT          reduce using rule 37 (expr -> NIL .)
    [               reduce using rule 37 (expr -> NIL .)
    $end            reduce using rule 37 (expr -> NIL .)
    }               reduce using rule 37 (expr -> NIL .)
    ELSE            reduce using rule 37 (expr -> NIL .)
    ]               reduce using rule 37 (expr -> NIL .)
    ,               reduce using rule 37 (expr -> NIL .)
    )               reduce using rule 37 (expr -> NIL .)
    TO              reduce using rule 37 (expr -> NIL .)
    :               reduce using rule 37 (expr -> NIL .)


state 23

    (104) list_val -> [ . exprs ]
    (105) exprs -> . exprs , expr
    (106) exprs -> . expr
    (107) exprs -> . empty
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (110) empty -> .
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    ]               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    [               shift and go to state 23

    exprs                          shift and go to state 99
    expr                           shift and go to state 100
    empty                          shift and go to state 101
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 24

    (40) expr -> list_val .
    SEP             reduce using rule 40 (expr -> list_val .)
    PERSENT         reduce using rule 40 (expr -> list_val .)
    DIV             reduce using rule 40 (expr -> list_val .)
    MUL             reduce using rule 40 (expr -> list_val .)
    SUB             reduce using rule 40 (expr -> list_val .)
    ADD             reduce using rule 40 (expr -> list_val .)
    %               reduce using rule 40 (expr -> list_val .)
    /               reduce using rule 40 (expr -> list_val .)
    *               reduce using rule 40 (expr -> list_val .)
    -               reduce using rule 40 (expr -> list_val .)
    +               reduce using rule 40 (expr -> list_val .)
    |               reduce using rule 40 (expr -> list_val .)
    ^               reduce using rule 40 (expr -> list_val .)
    &               reduce using rule 40 (expr -> list_val .)
    SHR             reduce using rule 40 (expr -> list_val .)
    SHL             reduce using rule 40 (expr -> list_val .)
    GREATER         reduce using rule 40 (expr -> list_val .)
    LESS            reduce using rule 40 (expr -> list_val .)
    OR              reduce using rule 40 (expr -> list_val .)
    AND             reduce using rule 40 (expr -> list_val .)
    GREATEREQ       reduce using rule 40 (expr -> list_val .)
    LESSEQ          reduce using rule 40 (expr -> list_val .)
    NOTEQ           reduce using rule 40 (expr -> list_val .)
    EQEQ            reduce using rule 40 (expr -> list_val .)
    ID              reduce using rule 40 (expr -> list_val .)
    ?               reduce using rule 40 (expr -> list_val .)
    LET             reduce using rule 40 (expr -> list_val .)
    PRINT           reduce using rule 40 (expr -> list_val .)
    RAW_INPUT       reduce using rule 40 (expr -> list_val .)
    {               reduce using rule 40 (expr -> list_val .)
    NIL             reduce using rule 40 (expr -> list_val .)
    FALSE           reduce using rule 40 (expr -> list_val .)
    TRUE            reduce using rule 40 (expr -> list_val .)
    STRING          reduce using rule 40 (expr -> list_val .)
    FLOAT           reduce using rule 40 (expr -> list_val .)
    INT             reduce using rule 40 (expr -> list_val .)
    (               reduce using rule 40 (expr -> list_val .)
    !               reduce using rule 40 (expr -> list_val .)
    ~               reduce using rule 40 (expr -> list_val .)
    TYPEOF          reduce using rule 40 (expr -> list_val .)
    LAMBDA          reduce using rule 40 (expr -> list_val .)
    DEC             reduce using rule 40 (expr -> list_val .)
    INC             reduce using rule 40 (expr -> list_val .)
    CLASS           reduce using rule 40 (expr -> list_val .)
    STRUCT          reduce using rule 40 (expr -> list_val .)
    IF              reduce using rule 40 (expr -> list_val .)
    FOR             reduce using rule 40 (expr -> list_val .)
    WHILE           reduce using rule 40 (expr -> list_val .)
    RETURN          reduce using rule 40 (expr -> list_val .)
    FN              reduce using rule 40 (expr -> list_val .)
    IMPORT          reduce using rule 40 (expr -> list_val .)
    [               reduce using rule 40 (expr -> list_val .)
    $end            reduce using rule 40 (expr -> list_val .)
    }               reduce using rule 40 (expr -> list_val .)
    ELSE            reduce using rule 40 (expr -> list_val .)
    ]               reduce using rule 40 (expr -> list_val .)
    ,               reduce using rule 40 (expr -> list_val .)
    )               reduce using rule 40 (expr -> list_val .)
    TO              reduce using rule 40 (expr -> list_val .)
    :               reduce using rule 40 (expr -> list_val .)


state 25

    (41) expr -> FALSE .
    SEP             reduce using rule 41 (expr -> FALSE .)
    PERSENT         reduce using rule 41 (expr -> FALSE .)
    DIV             reduce using rule 41 (expr -> FALSE .)
    MUL             reduce using rule 41 (expr -> FALSE .)
    SUB             reduce using rule 41 (expr -> FALSE .)
    ADD             reduce using rule 41 (expr -> FALSE .)
    %               reduce using rule 41 (expr -> FALSE .)
    /               reduce using rule 41 (expr -> FALSE .)
    *               reduce using rule 41 (expr -> FALSE .)
    -               reduce using rule 41 (expr -> FALSE .)
    +               reduce using rule 41 (expr -> FALSE .)
    |               reduce using rule 41 (expr -> FALSE .)
    ^               reduce using rule 41 (expr -> FALSE .)
    &               reduce using rule 41 (expr -> FALSE .)
    SHR             reduce using rule 41 (expr -> FALSE .)
    SHL             reduce using rule 41 (expr -> FALSE .)
    GREATER         reduce using rule 41 (expr -> FALSE .)
    LESS            reduce using rule 41 (expr -> FALSE .)
    OR              reduce using rule 41 (expr -> FALSE .)
    AND             reduce using rule 41 (expr -> FALSE .)
    GREATEREQ       reduce using rule 41 (expr -> FALSE .)
    LESSEQ          reduce using rule 41 (expr -> FALSE .)
    NOTEQ           reduce using rule 41 (expr -> FALSE .)
    EQEQ            reduce using rule 41 (expr -> FALSE .)
    ID              reduce using rule 41 (expr -> FALSE .)
    ?               reduce using rule 41 (expr -> FALSE .)
    LET             reduce using rule 41 (expr -> FALSE .)
    PRINT           reduce using rule 41 (expr -> FALSE .)
    RAW_INPUT       reduce using rule 41 (expr -> FALSE .)
    {               reduce using rule 41 (expr -> FALSE .)
    NIL             reduce using rule 41 (expr -> FALSE .)
    FALSE           reduce using rule 41 (expr -> FALSE .)
    TRUE            reduce using rule 41 (expr -> FALSE .)
    STRING          reduce using rule 41 (expr -> FALSE .)
    FLOAT           reduce using rule 41 (expr -> FALSE .)
    INT             reduce using rule 41 (expr -> FALSE .)
    (               reduce using rule 41 (expr -> FALSE .)
    !               reduce using rule 41 (expr -> FALSE .)
    ~               reduce using rule 41 (expr -> FALSE .)
    TYPEOF          reduce using rule 41 (expr -> FALSE .)
    LAMBDA          reduce using rule 41 (expr -> FALSE .)
    DEC             reduce using rule 41 (expr -> FALSE .)
    INC             reduce using rule 41 (expr -> FALSE .)
    CLASS           reduce using rule 41 (expr -> FALSE .)
    STRUCT          reduce using rule 41 (expr -> FALSE .)
    IF              reduce using rule 41 (expr -> FALSE .)
    FOR             reduce using rule 41 (expr -> FALSE .)
    WHILE           reduce using rule 41 (expr -> FALSE .)
    RETURN          reduce using rule 41 (expr -> FALSE .)
    FN              reduce using rule 41 (expr -> FALSE .)
    IMPORT          reduce using rule 41 (expr -> FALSE .)
    [               reduce using rule 41 (expr -> FALSE .)
    $end            reduce using rule 41 (expr -> FALSE .)
    }               reduce using rule 41 (expr -> FALSE .)
    ELSE            reduce using rule 41 (expr -> FALSE .)
    ]               reduce using rule 41 (expr -> FALSE .)
    ,               reduce using rule 41 (expr -> FALSE .)
    )               reduce using rule 41 (expr -> FALSE .)
    TO              reduce using rule 41 (expr -> FALSE .)
    :               reduce using rule 41 (expr -> FALSE .)


state 26

    (42) expr -> TRUE .
    SEP             reduce using rule 42 (expr -> TRUE .)
    PERSENT         reduce using rule 42 (expr -> TRUE .)
    DIV             reduce using rule 42 (expr -> TRUE .)
    MUL             reduce using rule 42 (expr -> TRUE .)
    SUB             reduce using rule 42 (expr -> TRUE .)
    ADD             reduce using rule 42 (expr -> TRUE .)
    %               reduce using rule 42 (expr -> TRUE .)
    /               reduce using rule 42 (expr -> TRUE .)
    *               reduce using rule 42 (expr -> TRUE .)
    -               reduce using rule 42 (expr -> TRUE .)
    +               reduce using rule 42 (expr -> TRUE .)
    |               reduce using rule 42 (expr -> TRUE .)
    ^               reduce using rule 42 (expr -> TRUE .)
    &               reduce using rule 42 (expr -> TRUE .)
    SHR             reduce using rule 42 (expr -> TRUE .)
    SHL             reduce using rule 42 (expr -> TRUE .)
    GREATER         reduce using rule 42 (expr -> TRUE .)
    LESS            reduce using rule 42 (expr -> TRUE .)
    OR              reduce using rule 42 (expr -> TRUE .)
    AND             reduce using rule 42 (expr -> TRUE .)
    GREATEREQ       reduce using rule 42 (expr -> TRUE .)
    LESSEQ          reduce using rule 42 (expr -> TRUE .)
    NOTEQ           reduce using rule 42 (expr -> TRUE .)
    EQEQ            reduce using rule 42 (expr -> TRUE .)
    ID              reduce using rule 42 (expr -> TRUE .)
    ?               reduce using rule 42 (expr -> TRUE .)
    LET             reduce using rule 42 (expr -> TRUE .)
    PRINT           reduce using rule 42 (expr -> TRUE .)
    RAW_INPUT       reduce using rule 42 (expr -> TRUE .)
    {               reduce using rule 42 (expr -> TRUE .)
    NIL             reduce using rule 42 (expr -> TRUE .)
    FALSE           reduce using rule 42 (expr -> TRUE .)
    TRUE            reduce using rule 42 (expr -> TRUE .)
    STRING          reduce using rule 42 (expr -> TRUE .)
    FLOAT           reduce using rule 42 (expr -> TRUE .)
    INT             reduce using rule 42 (expr -> TRUE .)
    (               reduce using rule 42 (expr -> TRUE .)
    !               reduce using rule 42 (expr -> TRUE .)
    ~               reduce using rule 42 (expr -> TRUE .)
    TYPEOF          reduce using rule 42 (expr -> TRUE .)
    LAMBDA          reduce using rule 42 (expr -> TRUE .)
    DEC             reduce using rule 42 (expr -> TRUE .)
    INC             reduce using rule 42 (expr -> TRUE .)
    CLASS           reduce using rule 42 (expr -> TRUE .)
    STRUCT          reduce using rule 42 (expr -> TRUE .)
    IF              reduce using rule 42 (expr -> TRUE .)
    FOR             reduce using rule 42 (expr -> TRUE .)
    WHILE           reduce using rule 42 (expr -> TRUE .)
    RETURN          reduce using rule 42 (expr -> TRUE .)
    FN              reduce using rule 42 (expr -> TRUE .)
    IMPORT          reduce using rule 42 (expr -> TRUE .)
    [               reduce using rule 42 (expr -> TRUE .)
    $end            reduce using rule 42 (expr -> TRUE .)
    }               reduce using rule 42 (expr -> TRUE .)
    ELSE            reduce using rule 42 (expr -> TRUE .)
    ]               reduce using rule 42 (expr -> TRUE .)
    ,               reduce using rule 42 (expr -> TRUE .)
    )               reduce using rule 42 (expr -> TRUE .)
    TO              reduce using rule 42 (expr -> TRUE .)
    :               reduce using rule 42 (expr -> TRUE .)


state 27

    (43) expr -> STRING .
    SEP             reduce using rule 43 (expr -> STRING .)
    PERSENT         reduce using rule 43 (expr -> STRING .)
    DIV             reduce using rule 43 (expr -> STRING .)
    MUL             reduce using rule 43 (expr -> STRING .)
    SUB             reduce using rule 43 (expr -> STRING .)
    ADD             reduce using rule 43 (expr -> STRING .)
    %               reduce using rule 43 (expr -> STRING .)
    /               reduce using rule 43 (expr -> STRING .)
    *               reduce using rule 43 (expr -> STRING .)
    -               reduce using rule 43 (expr -> STRING .)
    +               reduce using rule 43 (expr -> STRING .)
    |               reduce using rule 43 (expr -> STRING .)
    ^               reduce using rule 43 (expr -> STRING .)
    &               reduce using rule 43 (expr -> STRING .)
    SHR             reduce using rule 43 (expr -> STRING .)
    SHL             reduce using rule 43 (expr -> STRING .)
    GREATER         reduce using rule 43 (expr -> STRING .)
    LESS            reduce using rule 43 (expr -> STRING .)
    OR              reduce using rule 43 (expr -> STRING .)
    AND             reduce using rule 43 (expr -> STRING .)
    GREATEREQ       reduce using rule 43 (expr -> STRING .)
    LESSEQ          reduce using rule 43 (expr -> STRING .)
    NOTEQ           reduce using rule 43 (expr -> STRING .)
    EQEQ            reduce using rule 43 (expr -> STRING .)
    ID              reduce using rule 43 (expr -> STRING .)
    ?               reduce using rule 43 (expr -> STRING .)
    LET             reduce using rule 43 (expr -> STRING .)
    PRINT           reduce using rule 43 (expr -> STRING .)
    RAW_INPUT       reduce using rule 43 (expr -> STRING .)
    {               reduce using rule 43 (expr -> STRING .)
    NIL             reduce using rule 43 (expr -> STRING .)
    FALSE           reduce using rule 43 (expr -> STRING .)
    TRUE            reduce using rule 43 (expr -> STRING .)
    STRING          reduce using rule 43 (expr -> STRING .)
    FLOAT           reduce using rule 43 (expr -> STRING .)
    INT             reduce using rule 43 (expr -> STRING .)
    (               reduce using rule 43 (expr -> STRING .)
    !               reduce using rule 43 (expr -> STRING .)
    ~               reduce using rule 43 (expr -> STRING .)
    TYPEOF          reduce using rule 43 (expr -> STRING .)
    LAMBDA          reduce using rule 43 (expr -> STRING .)
    DEC             reduce using rule 43 (expr -> STRING .)
    INC             reduce using rule 43 (expr -> STRING .)
    CLASS           reduce using rule 43 (expr -> STRING .)
    STRUCT          reduce using rule 43 (expr -> STRING .)
    IF              reduce using rule 43 (expr -> STRING .)
    FOR             reduce using rule 43 (expr -> STRING .)
    WHILE           reduce using rule 43 (expr -> STRING .)
    RETURN          reduce using rule 43 (expr -> STRING .)
    FN              reduce using rule 43 (expr -> STRING .)
    IMPORT          reduce using rule 43 (expr -> STRING .)
    [               reduce using rule 43 (expr -> STRING .)
    $end            reduce using rule 43 (expr -> STRING .)
    }               reduce using rule 43 (expr -> STRING .)
    ELSE            reduce using rule 43 (expr -> STRING .)
    ]               reduce using rule 43 (expr -> STRING .)
    ,               reduce using rule 43 (expr -> STRING .)
    )               reduce using rule 43 (expr -> STRING .)
    TO              reduce using rule 43 (expr -> STRING .)
    :               reduce using rule 43 (expr -> STRING .)


state 28

    (44) expr -> FLOAT .
    SEP             reduce using rule 44 (expr -> FLOAT .)
    PERSENT         reduce using rule 44 (expr -> FLOAT .)
    DIV             reduce using rule 44 (expr -> FLOAT .)
    MUL             reduce using rule 44 (expr -> FLOAT .)
    SUB             reduce using rule 44 (expr -> FLOAT .)
    ADD             reduce using rule 44 (expr -> FLOAT .)
    %               reduce using rule 44 (expr -> FLOAT .)
    /               reduce using rule 44 (expr -> FLOAT .)
    *               reduce using rule 44 (expr -> FLOAT .)
    -               reduce using rule 44 (expr -> FLOAT .)
    +               reduce using rule 44 (expr -> FLOAT .)
    |               reduce using rule 44 (expr -> FLOAT .)
    ^               reduce using rule 44 (expr -> FLOAT .)
    &               reduce using rule 44 (expr -> FLOAT .)
    SHR             reduce using rule 44 (expr -> FLOAT .)
    SHL             reduce using rule 44 (expr -> FLOAT .)
    GREATER         reduce using rule 44 (expr -> FLOAT .)
    LESS            reduce using rule 44 (expr -> FLOAT .)
    OR              reduce using rule 44 (expr -> FLOAT .)
    AND             reduce using rule 44 (expr -> FLOAT .)
    GREATEREQ       reduce using rule 44 (expr -> FLOAT .)
    LESSEQ          reduce using rule 44 (expr -> FLOAT .)
    NOTEQ           reduce using rule 44 (expr -> FLOAT .)
    EQEQ            reduce using rule 44 (expr -> FLOAT .)
    ID              reduce using rule 44 (expr -> FLOAT .)
    ?               reduce using rule 44 (expr -> FLOAT .)
    LET             reduce using rule 44 (expr -> FLOAT .)
    PRINT           reduce using rule 44 (expr -> FLOAT .)
    RAW_INPUT       reduce using rule 44 (expr -> FLOAT .)
    {               reduce using rule 44 (expr -> FLOAT .)
    NIL             reduce using rule 44 (expr -> FLOAT .)
    FALSE           reduce using rule 44 (expr -> FLOAT .)
    TRUE            reduce using rule 44 (expr -> FLOAT .)
    STRING          reduce using rule 44 (expr -> FLOAT .)
    FLOAT           reduce using rule 44 (expr -> FLOAT .)
    INT             reduce using rule 44 (expr -> FLOAT .)
    (               reduce using rule 44 (expr -> FLOAT .)
    !               reduce using rule 44 (expr -> FLOAT .)
    ~               reduce using rule 44 (expr -> FLOAT .)
    TYPEOF          reduce using rule 44 (expr -> FLOAT .)
    LAMBDA          reduce using rule 44 (expr -> FLOAT .)
    DEC             reduce using rule 44 (expr -> FLOAT .)
    INC             reduce using rule 44 (expr -> FLOAT .)
    CLASS           reduce using rule 44 (expr -> FLOAT .)
    STRUCT          reduce using rule 44 (expr -> FLOAT .)
    IF              reduce using rule 44 (expr -> FLOAT .)
    FOR             reduce using rule 44 (expr -> FLOAT .)
    WHILE           reduce using rule 44 (expr -> FLOAT .)
    RETURN          reduce using rule 44 (expr -> FLOAT .)
    FN              reduce using rule 44 (expr -> FLOAT .)
    IMPORT          reduce using rule 44 (expr -> FLOAT .)
    [               reduce using rule 44 (expr -> FLOAT .)
    $end            reduce using rule 44 (expr -> FLOAT .)
    }               reduce using rule 44 (expr -> FLOAT .)
    ELSE            reduce using rule 44 (expr -> FLOAT .)
    ]               reduce using rule 44 (expr -> FLOAT .)
    ,               reduce using rule 44 (expr -> FLOAT .)
    )               reduce using rule 44 (expr -> FLOAT .)
    TO              reduce using rule 44 (expr -> FLOAT .)
    :               reduce using rule 44 (expr -> FLOAT .)


state 29

    (45) expr -> INT .
    SEP             reduce using rule 45 (expr -> INT .)
    PERSENT         reduce using rule 45 (expr -> INT .)
    DIV             reduce using rule 45 (expr -> INT .)
    MUL             reduce using rule 45 (expr -> INT .)
    SUB             reduce using rule 45 (expr -> INT .)
    ADD             reduce using rule 45 (expr -> INT .)
    %               reduce using rule 45 (expr -> INT .)
    /               reduce using rule 45 (expr -> INT .)
    *               reduce using rule 45 (expr -> INT .)
    -               reduce using rule 45 (expr -> INT .)
    +               reduce using rule 45 (expr -> INT .)
    |               reduce using rule 45 (expr -> INT .)
    ^               reduce using rule 45 (expr -> INT .)
    &               reduce using rule 45 (expr -> INT .)
    SHR             reduce using rule 45 (expr -> INT .)
    SHL             reduce using rule 45 (expr -> INT .)
    GREATER         reduce using rule 45 (expr -> INT .)
    LESS            reduce using rule 45 (expr -> INT .)
    OR              reduce using rule 45 (expr -> INT .)
    AND             reduce using rule 45 (expr -> INT .)
    GREATEREQ       reduce using rule 45 (expr -> INT .)
    LESSEQ          reduce using rule 45 (expr -> INT .)
    NOTEQ           reduce using rule 45 (expr -> INT .)
    EQEQ            reduce using rule 45 (expr -> INT .)
    ID              reduce using rule 45 (expr -> INT .)
    ?               reduce using rule 45 (expr -> INT .)
    LET             reduce using rule 45 (expr -> INT .)
    PRINT           reduce using rule 45 (expr -> INT .)
    RAW_INPUT       reduce using rule 45 (expr -> INT .)
    {               reduce using rule 45 (expr -> INT .)
    NIL             reduce using rule 45 (expr -> INT .)
    FALSE           reduce using rule 45 (expr -> INT .)
    TRUE            reduce using rule 45 (expr -> INT .)
    STRING          reduce using rule 45 (expr -> INT .)
    FLOAT           reduce using rule 45 (expr -> INT .)
    INT             reduce using rule 45 (expr -> INT .)
    (               reduce using rule 45 (expr -> INT .)
    !               reduce using rule 45 (expr -> INT .)
    ~               reduce using rule 45 (expr -> INT .)
    TYPEOF          reduce using rule 45 (expr -> INT .)
    LAMBDA          reduce using rule 45 (expr -> INT .)
    DEC             reduce using rule 45 (expr -> INT .)
    INC             reduce using rule 45 (expr -> INT .)
    CLASS           reduce using rule 45 (expr -> INT .)
    STRUCT          reduce using rule 45 (expr -> INT .)
    IF              reduce using rule 45 (expr -> INT .)
    FOR             reduce using rule 45 (expr -> INT .)
    WHILE           reduce using rule 45 (expr -> INT .)
    RETURN          reduce using rule 45 (expr -> INT .)
    FN              reduce using rule 45 (expr -> INT .)
    IMPORT          reduce using rule 45 (expr -> INT .)
    [               reduce using rule 45 (expr -> INT .)
    $end            reduce using rule 45 (expr -> INT .)
    }               reduce using rule 45 (expr -> INT .)
    ELSE            reduce using rule 45 (expr -> INT .)
    ]               reduce using rule 45 (expr -> INT .)
    ,               reduce using rule 45 (expr -> INT .)
    )               reduce using rule 45 (expr -> INT .)
    TO              reduce using rule 45 (expr -> INT .)
    :               reduce using rule 45 (expr -> INT .)


state 30

    (46) expr -> ( . expr )
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 102
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 31

    (59) expr -> - . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 103
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 32

    (58) expr -> + . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 104
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 33

    (57) expr -> ! . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 105
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 34

    (60) expr -> ~ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 106
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 35

    (75) expr -> ID . DOUBLECOLON ID ( args )
    (76) expr -> ID . ( args )
    (80) expr -> ID . LEFTARROW { struct_init_exprs }
    (125) getter -> ID .
    (109) var -> ID .
  ! shift/reduce conflict for ( resolved as shift
  ! reduce/reduce conflict for [ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for SEP resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for PERSENT resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for DIV resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for MUL resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for SUB resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ADD resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for % resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for / resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for * resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for - resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for + resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for | resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ^ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for & resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for SHR resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for SHL resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for EQEQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ? resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for LET resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for RAW_INPUT resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for { resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for NIL resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 109 (var -> ID .)
  ! shift/reduce conflict for ( resolved as shift
  ! reduce/reduce conflict for ! resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ~ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for TYPEOF resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for LAMBDA resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for DEC resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for INC resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for CLASS resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for STRUCT resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for FN resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for IMPORT resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for } resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ] resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for , resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for TO resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for : resolved using rule 109 (var -> ID .)
    DOUBLECOLON     shift and go to state 107
    (               shift and go to state 108
    LEFTARROW       shift and go to state 109
    .               reduce using rule 125 (getter -> ID .)
    [               reduce using rule 109 (var -> ID .)
    SHRASGN         reduce using rule 109 (var -> ID .)
    SHLASGN         reduce using rule 109 (var -> ID .)
    XORASGN         reduce using rule 109 (var -> ID .)
    ORASGN          reduce using rule 109 (var -> ID .)
    ANDASGN         reduce using rule 109 (var -> ID .)
    MODULOASGN      reduce using rule 109 (var -> ID .)
    SLASHASGN       reduce using rule 109 (var -> ID .)
    STARASGN        reduce using rule 109 (var -> ID .)
    MINUSASGN       reduce using rule 109 (var -> ID .)
    PLUSASGN        reduce using rule 109 (var -> ID .)
    ASSIGN          reduce using rule 109 (var -> ID .)
    SEP             reduce using rule 109 (var -> ID .)
    PERSENT         reduce using rule 109 (var -> ID .)
    DIV             reduce using rule 109 (var -> ID .)
    MUL             reduce using rule 109 (var -> ID .)
    SUB             reduce using rule 109 (var -> ID .)
    ADD             reduce using rule 109 (var -> ID .)
    %               reduce using rule 109 (var -> ID .)
    /               reduce using rule 109 (var -> ID .)
    *               reduce using rule 109 (var -> ID .)
    -               reduce using rule 109 (var -> ID .)
    +               reduce using rule 109 (var -> ID .)
    |               reduce using rule 109 (var -> ID .)
    ^               reduce using rule 109 (var -> ID .)
    &               reduce using rule 109 (var -> ID .)
    SHR             reduce using rule 109 (var -> ID .)
    SHL             reduce using rule 109 (var -> ID .)
    GREATER         reduce using rule 109 (var -> ID .)
    LESS            reduce using rule 109 (var -> ID .)
    OR              reduce using rule 109 (var -> ID .)
    AND             reduce using rule 109 (var -> ID .)
    GREATEREQ       reduce using rule 109 (var -> ID .)
    LESSEQ          reduce using rule 109 (var -> ID .)
    NOTEQ           reduce using rule 109 (var -> ID .)
    EQEQ            reduce using rule 109 (var -> ID .)
    ID              reduce using rule 109 (var -> ID .)
    ?               reduce using rule 109 (var -> ID .)
    LET             reduce using rule 109 (var -> ID .)
    PRINT           reduce using rule 109 (var -> ID .)
    RAW_INPUT       reduce using rule 109 (var -> ID .)
    {               reduce using rule 109 (var -> ID .)
    NIL             reduce using rule 109 (var -> ID .)
    FALSE           reduce using rule 109 (var -> ID .)
    TRUE            reduce using rule 109 (var -> ID .)
    STRING          reduce using rule 109 (var -> ID .)
    FLOAT           reduce using rule 109 (var -> ID .)
    INT             reduce using rule 109 (var -> ID .)
    !               reduce using rule 109 (var -> ID .)
    ~               reduce using rule 109 (var -> ID .)
    TYPEOF          reduce using rule 109 (var -> ID .)
    LAMBDA          reduce using rule 109 (var -> ID .)
    DEC             reduce using rule 109 (var -> ID .)
    INC             reduce using rule 109 (var -> ID .)
    CLASS           reduce using rule 109 (var -> ID .)
    STRUCT          reduce using rule 109 (var -> ID .)
    IF              reduce using rule 109 (var -> ID .)
    FOR             reduce using rule 109 (var -> ID .)
    WHILE           reduce using rule 109 (var -> ID .)
    RETURN          reduce using rule 109 (var -> ID .)
    FN              reduce using rule 109 (var -> ID .)
    IMPORT          reduce using rule 109 (var -> ID .)
    $end            reduce using rule 109 (var -> ID .)
    }               reduce using rule 109 (var -> ID .)
    ELSE            reduce using rule 109 (var -> ID .)
    ]               reduce using rule 109 (var -> ID .)
    ,               reduce using rule 109 (var -> ID .)
    )               reduce using rule 109 (var -> ID .)
    TO              reduce using rule 109 (var -> ID .)
    :               reduce using rule 109 (var -> ID .)


state 36

    (78) expr -> TYPEOF . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 110
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 37

    (79) expr -> LAMBDA . ( params ) ARROW expr
    (               shift and go to state 111


state 38

    (86) var_assign -> DEC . var
    (108) var -> . var [ expr ]
    (109) var -> . ID
    ID              shift and go to state 113

    var                            shift and go to state 112

state 39

    (87) var_assign -> INC . var
    (108) var -> . var [ expr ]
    (109) var -> . ID
    ID              shift and go to state 113

    var                            shift and go to state 114

state 40

    (19) class_definition -> CLASS . ID { function_definitions }
    ID              shift and go to state 115


state 41

    (23) struct_definition -> STRUCT . ID { struct_fields } SEP
    ID              shift and go to state 116


state 42

    (100) if_statement -> IF . expr block
    (101) if_statement -> IF . expr block ELSE block
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 117
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 43

    (103) for_statement -> FOR . expr TO expr block
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 118
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 44

    (102) while_statement -> WHILE . expr block
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 119
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 45

    (85) return_statement -> RETURN . expr SEP
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 120
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 46

    (34) function_definition -> FN . ID ( params ) block
    ID              shift and go to state 121


state 47

    (33) import_statement -> IMPORT . STRING SEP
    STRING          shift and go to state 122


state 48

    (3) statements -> statements statement .
    LET             reduce using rule 3 (statements -> statements statement .)
    PRINT           reduce using rule 3 (statements -> statements statement .)
    RAW_INPUT       reduce using rule 3 (statements -> statements statement .)
    {               reduce using rule 3 (statements -> statements statement .)
    NIL             reduce using rule 3 (statements -> statements statement .)
    FALSE           reduce using rule 3 (statements -> statements statement .)
    TRUE            reduce using rule 3 (statements -> statements statement .)
    STRING          reduce using rule 3 (statements -> statements statement .)
    FLOAT           reduce using rule 3 (statements -> statements statement .)
    INT             reduce using rule 3 (statements -> statements statement .)
    (               reduce using rule 3 (statements -> statements statement .)
    !               reduce using rule 3 (statements -> statements statement .)
    +               reduce using rule 3 (statements -> statements statement .)
    -               reduce using rule 3 (statements -> statements statement .)
    ~               reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    TYPEOF          reduce using rule 3 (statements -> statements statement .)
    LAMBDA          reduce using rule 3 (statements -> statements statement .)
    DEC             reduce using rule 3 (statements -> statements statement .)
    INC             reduce using rule 3 (statements -> statements statement .)
    CLASS           reduce using rule 3 (statements -> statements statement .)
    STRUCT          reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    FN              reduce using rule 3 (statements -> statements statement .)
    IMPORT          reduce using rule 3 (statements -> statements statement .)
    [               reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 49

    (5) statement -> expr SEP .
    LET             reduce using rule 5 (statement -> expr SEP .)
    PRINT           reduce using rule 5 (statement -> expr SEP .)
    RAW_INPUT       reduce using rule 5 (statement -> expr SEP .)
    {               reduce using rule 5 (statement -> expr SEP .)
    NIL             reduce using rule 5 (statement -> expr SEP .)
    FALSE           reduce using rule 5 (statement -> expr SEP .)
    TRUE            reduce using rule 5 (statement -> expr SEP .)
    STRING          reduce using rule 5 (statement -> expr SEP .)
    FLOAT           reduce using rule 5 (statement -> expr SEP .)
    INT             reduce using rule 5 (statement -> expr SEP .)
    (               reduce using rule 5 (statement -> expr SEP .)
    !               reduce using rule 5 (statement -> expr SEP .)
    +               reduce using rule 5 (statement -> expr SEP .)
    -               reduce using rule 5 (statement -> expr SEP .)
    ~               reduce using rule 5 (statement -> expr SEP .)
    ID              reduce using rule 5 (statement -> expr SEP .)
    TYPEOF          reduce using rule 5 (statement -> expr SEP .)
    LAMBDA          reduce using rule 5 (statement -> expr SEP .)
    DEC             reduce using rule 5 (statement -> expr SEP .)
    INC             reduce using rule 5 (statement -> expr SEP .)
    CLASS           reduce using rule 5 (statement -> expr SEP .)
    STRUCT          reduce using rule 5 (statement -> expr SEP .)
    IF              reduce using rule 5 (statement -> expr SEP .)
    FOR             reduce using rule 5 (statement -> expr SEP .)
    WHILE           reduce using rule 5 (statement -> expr SEP .)
    RETURN          reduce using rule 5 (statement -> expr SEP .)
    FN              reduce using rule 5 (statement -> expr SEP .)
    IMPORT          reduce using rule 5 (statement -> expr SEP .)
    [               reduce using rule 5 (statement -> expr SEP .)
    $end            reduce using rule 5 (statement -> expr SEP .)
    }               reduce using rule 5 (statement -> expr SEP .)
    ELSE            reduce using rule 5 (statement -> expr SEP .)


state 50

    (47) expr -> expr PERSENT . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 123
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 51

    (48) expr -> expr DIV . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 124
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 52

    (49) expr -> expr MUL . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 125
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 53

    (50) expr -> expr SUB . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 126
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 54

    (51) expr -> expr ADD . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 127
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 55

    (52) expr -> expr % . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 128
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 56

    (53) expr -> expr / . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 129
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 57

    (54) expr -> expr * . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 130
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 58

    (55) expr -> expr - . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 131
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 59

    (56) expr -> expr + . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 132
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 60

    (61) expr -> expr | . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 133
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 61

    (62) expr -> expr ^ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 134
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 62

    (63) expr -> expr & . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 135
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 63

    (64) expr -> expr SHR . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 136
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 64

    (65) expr -> expr SHL . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 137
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 65

    (66) expr -> expr GREATER . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 138
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 66

    (67) expr -> expr LESS . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 139
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 67

    (68) expr -> expr OR . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 140
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 68

    (69) expr -> expr AND . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 141
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 69

    (70) expr -> expr GREATEREQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 142
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 70

    (71) expr -> expr LESSEQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 143
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 71

    (72) expr -> expr NOTEQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 144
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 72

    (73) expr -> expr EQEQ . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 145
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 73

    (74) expr -> expr ID . ( args )
    (               shift and go to state 146


state 74

    (77) expr -> expr ? . expr : expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 147
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 75

    (6) statement -> var_assign SEP .
    LET             reduce using rule 6 (statement -> var_assign SEP .)
    PRINT           reduce using rule 6 (statement -> var_assign SEP .)
    RAW_INPUT       reduce using rule 6 (statement -> var_assign SEP .)
    {               reduce using rule 6 (statement -> var_assign SEP .)
    NIL             reduce using rule 6 (statement -> var_assign SEP .)
    FALSE           reduce using rule 6 (statement -> var_assign SEP .)
    TRUE            reduce using rule 6 (statement -> var_assign SEP .)
    STRING          reduce using rule 6 (statement -> var_assign SEP .)
    FLOAT           reduce using rule 6 (statement -> var_assign SEP .)
    INT             reduce using rule 6 (statement -> var_assign SEP .)
    (               reduce using rule 6 (statement -> var_assign SEP .)
    !               reduce using rule 6 (statement -> var_assign SEP .)
    +               reduce using rule 6 (statement -> var_assign SEP .)
    -               reduce using rule 6 (statement -> var_assign SEP .)
    ~               reduce using rule 6 (statement -> var_assign SEP .)
    ID              reduce using rule 6 (statement -> var_assign SEP .)
    TYPEOF          reduce using rule 6 (statement -> var_assign SEP .)
    LAMBDA          reduce using rule 6 (statement -> var_assign SEP .)
    DEC             reduce using rule 6 (statement -> var_assign SEP .)
    INC             reduce using rule 6 (statement -> var_assign SEP .)
    CLASS           reduce using rule 6 (statement -> var_assign SEP .)
    STRUCT          reduce using rule 6 (statement -> var_assign SEP .)
    IF              reduce using rule 6 (statement -> var_assign SEP .)
    FOR             reduce using rule 6 (statement -> var_assign SEP .)
    WHILE           reduce using rule 6 (statement -> var_assign SEP .)
    RETURN          reduce using rule 6 (statement -> var_assign SEP .)
    FN              reduce using rule 6 (statement -> var_assign SEP .)
    IMPORT          reduce using rule 6 (statement -> var_assign SEP .)
    [               reduce using rule 6 (statement -> var_assign SEP .)
    $end            reduce using rule 6 (statement -> var_assign SEP .)
    }               reduce using rule 6 (statement -> var_assign SEP .)
    ELSE            reduce using rule 6 (statement -> var_assign SEP .)


state 76

    (7) statement -> LET var . : var_type SEP
    (84) var_define -> LET var . ASSIGN expr
    (108) var -> var . [ expr ]
    :               shift and go to state 148
    ASSIGN          shift and go to state 149
    [               shift and go to state 150


state 77

    (83) var_define -> LET getter . ASSIGN expr
    (126) getter -> getter . . ID
    ASSIGN          shift and go to state 151
    .               shift and go to state 94


state 78

    (109) var -> ID .
    (125) getter -> ID .
  ! reduce/reduce conflict for ASSIGN resolved using rule 109 (var -> ID .)
    :               reduce using rule 109 (var -> ID .)
    ASSIGN          reduce using rule 109 (var -> ID .)
    [               reduce using rule 109 (var -> ID .)
    .               reduce using rule 125 (getter -> ID .)


state 79

    (39) expr -> var [ . expr ]
    (108) var -> var [ . expr ]
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 152
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 80

    (88) var_assign -> var SHRASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 153
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 81

    (89) var_assign -> var SHLASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 154
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 82

    (90) var_assign -> var XORASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 155
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 83

    (91) var_assign -> var ORASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 156
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 84

    (92) var_assign -> var ANDASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 157
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 85

    (93) var_assign -> var MODULOASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 158
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 86

    (94) var_assign -> var SLASHASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 159
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 87

    (95) var_assign -> var STARASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 160
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 88

    (96) var_assign -> var MINUSASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 161
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 89

    (97) var_assign -> var PLUSASGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 162
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 90

    (98) var_assign -> var ASSIGN . RAW_INPUT
    (99) var_assign -> var ASSIGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    RAW_INPUT       shift and go to state 163
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 164
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 91

    (8) statement -> PRINT expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    LET             reduce using rule 8 (statement -> PRINT expr .)
    PRINT           reduce using rule 8 (statement -> PRINT expr .)
    RAW_INPUT       reduce using rule 8 (statement -> PRINT expr .)
    {               reduce using rule 8 (statement -> PRINT expr .)
    NIL             reduce using rule 8 (statement -> PRINT expr .)
    FALSE           reduce using rule 8 (statement -> PRINT expr .)
    TRUE            reduce using rule 8 (statement -> PRINT expr .)
    STRING          reduce using rule 8 (statement -> PRINT expr .)
    FLOAT           reduce using rule 8 (statement -> PRINT expr .)
    INT             reduce using rule 8 (statement -> PRINT expr .)
    (               reduce using rule 8 (statement -> PRINT expr .)
    !               reduce using rule 8 (statement -> PRINT expr .)
    ~               reduce using rule 8 (statement -> PRINT expr .)
    TYPEOF          reduce using rule 8 (statement -> PRINT expr .)
    LAMBDA          reduce using rule 8 (statement -> PRINT expr .)
    DEC             reduce using rule 8 (statement -> PRINT expr .)
    INC             reduce using rule 8 (statement -> PRINT expr .)
    CLASS           reduce using rule 8 (statement -> PRINT expr .)
    STRUCT          reduce using rule 8 (statement -> PRINT expr .)
    IF              reduce using rule 8 (statement -> PRINT expr .)
    FOR             reduce using rule 8 (statement -> PRINT expr .)
    WHILE           reduce using rule 8 (statement -> PRINT expr .)
    RETURN          reduce using rule 8 (statement -> PRINT expr .)
    FN              reduce using rule 8 (statement -> PRINT expr .)
    IMPORT          reduce using rule 8 (statement -> PRINT expr .)
    [               reduce using rule 8 (statement -> PRINT expr .)
    $end            reduce using rule 8 (statement -> PRINT expr .)
    }               reduce using rule 8 (statement -> PRINT expr .)
    ELSE            reduce using rule 8 (statement -> PRINT expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 92

    (38) expr -> var .
    (39) expr -> var . [ expr ]
    (108) var -> var . [ expr ]
  ! shift/reduce conflict for [ resolved as shift
    PERSENT         reduce using rule 38 (expr -> var .)
    DIV             reduce using rule 38 (expr -> var .)
    MUL             reduce using rule 38 (expr -> var .)
    SUB             reduce using rule 38 (expr -> var .)
    ADD             reduce using rule 38 (expr -> var .)
    %               reduce using rule 38 (expr -> var .)
    /               reduce using rule 38 (expr -> var .)
    *               reduce using rule 38 (expr -> var .)
    -               reduce using rule 38 (expr -> var .)
    +               reduce using rule 38 (expr -> var .)
    |               reduce using rule 38 (expr -> var .)
    ^               reduce using rule 38 (expr -> var .)
    &               reduce using rule 38 (expr -> var .)
    SHR             reduce using rule 38 (expr -> var .)
    SHL             reduce using rule 38 (expr -> var .)
    GREATER         reduce using rule 38 (expr -> var .)
    LESS            reduce using rule 38 (expr -> var .)
    OR              reduce using rule 38 (expr -> var .)
    AND             reduce using rule 38 (expr -> var .)
    GREATEREQ       reduce using rule 38 (expr -> var .)
    LESSEQ          reduce using rule 38 (expr -> var .)
    NOTEQ           reduce using rule 38 (expr -> var .)
    EQEQ            reduce using rule 38 (expr -> var .)
    ID              reduce using rule 38 (expr -> var .)
    ?               reduce using rule 38 (expr -> var .)
    LET             reduce using rule 38 (expr -> var .)
    PRINT           reduce using rule 38 (expr -> var .)
    RAW_INPUT       reduce using rule 38 (expr -> var .)
    {               reduce using rule 38 (expr -> var .)
    NIL             reduce using rule 38 (expr -> var .)
    FALSE           reduce using rule 38 (expr -> var .)
    TRUE            reduce using rule 38 (expr -> var .)
    STRING          reduce using rule 38 (expr -> var .)
    FLOAT           reduce using rule 38 (expr -> var .)
    INT             reduce using rule 38 (expr -> var .)
    (               reduce using rule 38 (expr -> var .)
    !               reduce using rule 38 (expr -> var .)
    ~               reduce using rule 38 (expr -> var .)
    TYPEOF          reduce using rule 38 (expr -> var .)
    LAMBDA          reduce using rule 38 (expr -> var .)
    DEC             reduce using rule 38 (expr -> var .)
    INC             reduce using rule 38 (expr -> var .)
    CLASS           reduce using rule 38 (expr -> var .)
    STRUCT          reduce using rule 38 (expr -> var .)
    IF              reduce using rule 38 (expr -> var .)
    FOR             reduce using rule 38 (expr -> var .)
    WHILE           reduce using rule 38 (expr -> var .)
    RETURN          reduce using rule 38 (expr -> var .)
    FN              reduce using rule 38 (expr -> var .)
    IMPORT          reduce using rule 38 (expr -> var .)
    $end            reduce using rule 38 (expr -> var .)
    }               reduce using rule 38 (expr -> var .)
    ELSE            reduce using rule 38 (expr -> var .)
    ]               reduce using rule 38 (expr -> var .)
    ,               reduce using rule 38 (expr -> var .)
    )               reduce using rule 38 (expr -> var .)
    SEP             reduce using rule 38 (expr -> var .)
    TO              reduce using rule 38 (expr -> var .)
    :               reduce using rule 38 (expr -> var .)
    [               shift and go to state 79


state 93

    (9) statement -> var_define SEP .
    LET             reduce using rule 9 (statement -> var_define SEP .)
    PRINT           reduce using rule 9 (statement -> var_define SEP .)
    RAW_INPUT       reduce using rule 9 (statement -> var_define SEP .)
    {               reduce using rule 9 (statement -> var_define SEP .)
    NIL             reduce using rule 9 (statement -> var_define SEP .)
    FALSE           reduce using rule 9 (statement -> var_define SEP .)
    TRUE            reduce using rule 9 (statement -> var_define SEP .)
    STRING          reduce using rule 9 (statement -> var_define SEP .)
    FLOAT           reduce using rule 9 (statement -> var_define SEP .)
    INT             reduce using rule 9 (statement -> var_define SEP .)
    (               reduce using rule 9 (statement -> var_define SEP .)
    !               reduce using rule 9 (statement -> var_define SEP .)
    +               reduce using rule 9 (statement -> var_define SEP .)
    -               reduce using rule 9 (statement -> var_define SEP .)
    ~               reduce using rule 9 (statement -> var_define SEP .)
    ID              reduce using rule 9 (statement -> var_define SEP .)
    TYPEOF          reduce using rule 9 (statement -> var_define SEP .)
    LAMBDA          reduce using rule 9 (statement -> var_define SEP .)
    DEC             reduce using rule 9 (statement -> var_define SEP .)
    INC             reduce using rule 9 (statement -> var_define SEP .)
    CLASS           reduce using rule 9 (statement -> var_define SEP .)
    STRUCT          reduce using rule 9 (statement -> var_define SEP .)
    IF              reduce using rule 9 (statement -> var_define SEP .)
    FOR             reduce using rule 9 (statement -> var_define SEP .)
    WHILE           reduce using rule 9 (statement -> var_define SEP .)
    RETURN          reduce using rule 9 (statement -> var_define SEP .)
    FN              reduce using rule 9 (statement -> var_define SEP .)
    IMPORT          reduce using rule 9 (statement -> var_define SEP .)
    [               reduce using rule 9 (statement -> var_define SEP .)
    $end            reduce using rule 9 (statement -> var_define SEP .)
    }               reduce using rule 9 (statement -> var_define SEP .)
    ELSE            reduce using rule 9 (statement -> var_define SEP .)


state 94

    (126) getter -> getter . . ID
    ID              shift and go to state 165


state 95

    (36) expr -> { member_list . }
    (121) member_list -> member_list . , member
    }               shift and go to state 166
    ,               shift and go to state 167


state 96

    (122) member_list -> member .
    }               reduce using rule 122 (member_list -> member .)
    ,               reduce using rule 122 (member_list -> member .)


state 97

    (123) member_list -> empty .
    }               reduce using rule 123 (member_list -> empty .)
    ,               reduce using rule 123 (member_list -> empty .)


state 98

    (124) member -> STRING . : expr
    :               shift and go to state 168


state 99

    (104) list_val -> [ exprs . ]
    (105) exprs -> exprs . , expr
    ]               shift and go to state 169
    ,               shift and go to state 170


state 100

    (106) exprs -> expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    ]               reduce using rule 106 (exprs -> expr .)
    ,               reduce using rule 106 (exprs -> expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 101

    (107) exprs -> empty .
    ]               reduce using rule 107 (exprs -> empty .)
    ,               reduce using rule 107 (exprs -> empty .)


state 102

    (46) expr -> ( expr . )
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    )               shift and go to state 171
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 103

    (59) expr -> - expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 59 (expr -> - expr .)
    PERSENT         reduce using rule 59 (expr -> - expr .)
    DIV             reduce using rule 59 (expr -> - expr .)
    MUL             reduce using rule 59 (expr -> - expr .)
    SUB             reduce using rule 59 (expr -> - expr .)
    ADD             reduce using rule 59 (expr -> - expr .)
    %               reduce using rule 59 (expr -> - expr .)
    /               reduce using rule 59 (expr -> - expr .)
    *               reduce using rule 59 (expr -> - expr .)
    -               reduce using rule 59 (expr -> - expr .)
    +               reduce using rule 59 (expr -> - expr .)
    |               reduce using rule 59 (expr -> - expr .)
    ^               reduce using rule 59 (expr -> - expr .)
    &               reduce using rule 59 (expr -> - expr .)
    SHR             reduce using rule 59 (expr -> - expr .)
    SHL             reduce using rule 59 (expr -> - expr .)
    GREATER         reduce using rule 59 (expr -> - expr .)
    LESS            reduce using rule 59 (expr -> - expr .)
    OR              reduce using rule 59 (expr -> - expr .)
    AND             reduce using rule 59 (expr -> - expr .)
    GREATEREQ       reduce using rule 59 (expr -> - expr .)
    LESSEQ          reduce using rule 59 (expr -> - expr .)
    NOTEQ           reduce using rule 59 (expr -> - expr .)
    EQEQ            reduce using rule 59 (expr -> - expr .)
    ID              reduce using rule 59 (expr -> - expr .)
    ?               reduce using rule 59 (expr -> - expr .)
    LET             reduce using rule 59 (expr -> - expr .)
    PRINT           reduce using rule 59 (expr -> - expr .)
    RAW_INPUT       reduce using rule 59 (expr -> - expr .)
    {               reduce using rule 59 (expr -> - expr .)
    NIL             reduce using rule 59 (expr -> - expr .)
    FALSE           reduce using rule 59 (expr -> - expr .)
    TRUE            reduce using rule 59 (expr -> - expr .)
    STRING          reduce using rule 59 (expr -> - expr .)
    FLOAT           reduce using rule 59 (expr -> - expr .)
    INT             reduce using rule 59 (expr -> - expr .)
    (               reduce using rule 59 (expr -> - expr .)
    !               reduce using rule 59 (expr -> - expr .)
    ~               reduce using rule 59 (expr -> - expr .)
    TYPEOF          reduce using rule 59 (expr -> - expr .)
    LAMBDA          reduce using rule 59 (expr -> - expr .)
    DEC             reduce using rule 59 (expr -> - expr .)
    INC             reduce using rule 59 (expr -> - expr .)
    CLASS           reduce using rule 59 (expr -> - expr .)
    STRUCT          reduce using rule 59 (expr -> - expr .)
    IF              reduce using rule 59 (expr -> - expr .)
    FOR             reduce using rule 59 (expr -> - expr .)
    WHILE           reduce using rule 59 (expr -> - expr .)
    RETURN          reduce using rule 59 (expr -> - expr .)
    FN              reduce using rule 59 (expr -> - expr .)
    IMPORT          reduce using rule 59 (expr -> - expr .)
    [               reduce using rule 59 (expr -> - expr .)
    $end            reduce using rule 59 (expr -> - expr .)
    }               reduce using rule 59 (expr -> - expr .)
    ELSE            reduce using rule 59 (expr -> - expr .)
    ]               reduce using rule 59 (expr -> - expr .)
    ,               reduce using rule 59 (expr -> - expr .)
    )               reduce using rule 59 (expr -> - expr .)
    TO              reduce using rule 59 (expr -> - expr .)
    :               reduce using rule 59 (expr -> - expr .)


state 104

    (58) expr -> + expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 58 (expr -> + expr .)
    PERSENT         reduce using rule 58 (expr -> + expr .)
    DIV             reduce using rule 58 (expr -> + expr .)
    MUL             reduce using rule 58 (expr -> + expr .)
    SUB             reduce using rule 58 (expr -> + expr .)
    ADD             reduce using rule 58 (expr -> + expr .)
    %               reduce using rule 58 (expr -> + expr .)
    /               reduce using rule 58 (expr -> + expr .)
    *               reduce using rule 58 (expr -> + expr .)
    -               reduce using rule 58 (expr -> + expr .)
    +               reduce using rule 58 (expr -> + expr .)
    |               reduce using rule 58 (expr -> + expr .)
    ^               reduce using rule 58 (expr -> + expr .)
    &               reduce using rule 58 (expr -> + expr .)
    SHR             reduce using rule 58 (expr -> + expr .)
    SHL             reduce using rule 58 (expr -> + expr .)
    GREATER         reduce using rule 58 (expr -> + expr .)
    LESS            reduce using rule 58 (expr -> + expr .)
    OR              reduce using rule 58 (expr -> + expr .)
    AND             reduce using rule 58 (expr -> + expr .)
    GREATEREQ       reduce using rule 58 (expr -> + expr .)
    LESSEQ          reduce using rule 58 (expr -> + expr .)
    NOTEQ           reduce using rule 58 (expr -> + expr .)
    EQEQ            reduce using rule 58 (expr -> + expr .)
    ID              reduce using rule 58 (expr -> + expr .)
    ?               reduce using rule 58 (expr -> + expr .)
    LET             reduce using rule 58 (expr -> + expr .)
    PRINT           reduce using rule 58 (expr -> + expr .)
    RAW_INPUT       reduce using rule 58 (expr -> + expr .)
    {               reduce using rule 58 (expr -> + expr .)
    NIL             reduce using rule 58 (expr -> + expr .)
    FALSE           reduce using rule 58 (expr -> + expr .)
    TRUE            reduce using rule 58 (expr -> + expr .)
    STRING          reduce using rule 58 (expr -> + expr .)
    FLOAT           reduce using rule 58 (expr -> + expr .)
    INT             reduce using rule 58 (expr -> + expr .)
    (               reduce using rule 58 (expr -> + expr .)
    !               reduce using rule 58 (expr -> + expr .)
    ~               reduce using rule 58 (expr -> + expr .)
    TYPEOF          reduce using rule 58 (expr -> + expr .)
    LAMBDA          reduce using rule 58 (expr -> + expr .)
    DEC             reduce using rule 58 (expr -> + expr .)
    INC             reduce using rule 58 (expr -> + expr .)
    CLASS           reduce using rule 58 (expr -> + expr .)
    STRUCT          reduce using rule 58 (expr -> + expr .)
    IF              reduce using rule 58 (expr -> + expr .)
    FOR             reduce using rule 58 (expr -> + expr .)
    WHILE           reduce using rule 58 (expr -> + expr .)
    RETURN          reduce using rule 58 (expr -> + expr .)
    FN              reduce using rule 58 (expr -> + expr .)
    IMPORT          reduce using rule 58 (expr -> + expr .)
    [               reduce using rule 58 (expr -> + expr .)
    $end            reduce using rule 58 (expr -> + expr .)
    }               reduce using rule 58 (expr -> + expr .)
    ELSE            reduce using rule 58 (expr -> + expr .)
    ]               reduce using rule 58 (expr -> + expr .)
    ,               reduce using rule 58 (expr -> + expr .)
    )               reduce using rule 58 (expr -> + expr .)
    TO              reduce using rule 58 (expr -> + expr .)
    :               reduce using rule 58 (expr -> + expr .)


state 105

    (57) expr -> ! expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 57 (expr -> ! expr .)
    PERSENT         reduce using rule 57 (expr -> ! expr .)
    DIV             reduce using rule 57 (expr -> ! expr .)
    MUL             reduce using rule 57 (expr -> ! expr .)
    SUB             reduce using rule 57 (expr -> ! expr .)
    ADD             reduce using rule 57 (expr -> ! expr .)
    %               reduce using rule 57 (expr -> ! expr .)
    /               reduce using rule 57 (expr -> ! expr .)
    *               reduce using rule 57 (expr -> ! expr .)
    -               reduce using rule 57 (expr -> ! expr .)
    +               reduce using rule 57 (expr -> ! expr .)
    |               reduce using rule 57 (expr -> ! expr .)
    ^               reduce using rule 57 (expr -> ! expr .)
    &               reduce using rule 57 (expr -> ! expr .)
    SHR             reduce using rule 57 (expr -> ! expr .)
    SHL             reduce using rule 57 (expr -> ! expr .)
    GREATER         reduce using rule 57 (expr -> ! expr .)
    LESS            reduce using rule 57 (expr -> ! expr .)
    OR              reduce using rule 57 (expr -> ! expr .)
    AND             reduce using rule 57 (expr -> ! expr .)
    GREATEREQ       reduce using rule 57 (expr -> ! expr .)
    LESSEQ          reduce using rule 57 (expr -> ! expr .)
    NOTEQ           reduce using rule 57 (expr -> ! expr .)
    EQEQ            reduce using rule 57 (expr -> ! expr .)
    ID              reduce using rule 57 (expr -> ! expr .)
    ?               reduce using rule 57 (expr -> ! expr .)
    LET             reduce using rule 57 (expr -> ! expr .)
    PRINT           reduce using rule 57 (expr -> ! expr .)
    RAW_INPUT       reduce using rule 57 (expr -> ! expr .)
    {               reduce using rule 57 (expr -> ! expr .)
    NIL             reduce using rule 57 (expr -> ! expr .)
    FALSE           reduce using rule 57 (expr -> ! expr .)
    TRUE            reduce using rule 57 (expr -> ! expr .)
    STRING          reduce using rule 57 (expr -> ! expr .)
    FLOAT           reduce using rule 57 (expr -> ! expr .)
    INT             reduce using rule 57 (expr -> ! expr .)
    (               reduce using rule 57 (expr -> ! expr .)
    !               reduce using rule 57 (expr -> ! expr .)
    ~               reduce using rule 57 (expr -> ! expr .)
    TYPEOF          reduce using rule 57 (expr -> ! expr .)
    LAMBDA          reduce using rule 57 (expr -> ! expr .)
    DEC             reduce using rule 57 (expr -> ! expr .)
    INC             reduce using rule 57 (expr -> ! expr .)
    CLASS           reduce using rule 57 (expr -> ! expr .)
    STRUCT          reduce using rule 57 (expr -> ! expr .)
    IF              reduce using rule 57 (expr -> ! expr .)
    FOR             reduce using rule 57 (expr -> ! expr .)
    WHILE           reduce using rule 57 (expr -> ! expr .)
    RETURN          reduce using rule 57 (expr -> ! expr .)
    FN              reduce using rule 57 (expr -> ! expr .)
    IMPORT          reduce using rule 57 (expr -> ! expr .)
    [               reduce using rule 57 (expr -> ! expr .)
    $end            reduce using rule 57 (expr -> ! expr .)
    }               reduce using rule 57 (expr -> ! expr .)
    ELSE            reduce using rule 57 (expr -> ! expr .)
    ]               reduce using rule 57 (expr -> ! expr .)
    ,               reduce using rule 57 (expr -> ! expr .)
    )               reduce using rule 57 (expr -> ! expr .)
    TO              reduce using rule 57 (expr -> ! expr .)
    :               reduce using rule 57 (expr -> ! expr .)


state 106

    (60) expr -> ~ expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 60 (expr -> ~ expr .)
    PERSENT         reduce using rule 60 (expr -> ~ expr .)
    DIV             reduce using rule 60 (expr -> ~ expr .)
    MUL             reduce using rule 60 (expr -> ~ expr .)
    SUB             reduce using rule 60 (expr -> ~ expr .)
    ADD             reduce using rule 60 (expr -> ~ expr .)
    %               reduce using rule 60 (expr -> ~ expr .)
    /               reduce using rule 60 (expr -> ~ expr .)
    *               reduce using rule 60 (expr -> ~ expr .)
    -               reduce using rule 60 (expr -> ~ expr .)
    +               reduce using rule 60 (expr -> ~ expr .)
    |               reduce using rule 60 (expr -> ~ expr .)
    ^               reduce using rule 60 (expr -> ~ expr .)
    &               reduce using rule 60 (expr -> ~ expr .)
    SHR             reduce using rule 60 (expr -> ~ expr .)
    SHL             reduce using rule 60 (expr -> ~ expr .)
    GREATER         reduce using rule 60 (expr -> ~ expr .)
    LESS            reduce using rule 60 (expr -> ~ expr .)
    OR              reduce using rule 60 (expr -> ~ expr .)
    AND             reduce using rule 60 (expr -> ~ expr .)
    GREATEREQ       reduce using rule 60 (expr -> ~ expr .)
    LESSEQ          reduce using rule 60 (expr -> ~ expr .)
    NOTEQ           reduce using rule 60 (expr -> ~ expr .)
    EQEQ            reduce using rule 60 (expr -> ~ expr .)
    ID              reduce using rule 60 (expr -> ~ expr .)
    ?               reduce using rule 60 (expr -> ~ expr .)
    LET             reduce using rule 60 (expr -> ~ expr .)
    PRINT           reduce using rule 60 (expr -> ~ expr .)
    RAW_INPUT       reduce using rule 60 (expr -> ~ expr .)
    {               reduce using rule 60 (expr -> ~ expr .)
    NIL             reduce using rule 60 (expr -> ~ expr .)
    FALSE           reduce using rule 60 (expr -> ~ expr .)
    TRUE            reduce using rule 60 (expr -> ~ expr .)
    STRING          reduce using rule 60 (expr -> ~ expr .)
    FLOAT           reduce using rule 60 (expr -> ~ expr .)
    INT             reduce using rule 60 (expr -> ~ expr .)
    (               reduce using rule 60 (expr -> ~ expr .)
    !               reduce using rule 60 (expr -> ~ expr .)
    ~               reduce using rule 60 (expr -> ~ expr .)
    TYPEOF          reduce using rule 60 (expr -> ~ expr .)
    LAMBDA          reduce using rule 60 (expr -> ~ expr .)
    DEC             reduce using rule 60 (expr -> ~ expr .)
    INC             reduce using rule 60 (expr -> ~ expr .)
    CLASS           reduce using rule 60 (expr -> ~ expr .)
    STRUCT          reduce using rule 60 (expr -> ~ expr .)
    IF              reduce using rule 60 (expr -> ~ expr .)
    FOR             reduce using rule 60 (expr -> ~ expr .)
    WHILE           reduce using rule 60 (expr -> ~ expr .)
    RETURN          reduce using rule 60 (expr -> ~ expr .)
    FN              reduce using rule 60 (expr -> ~ expr .)
    IMPORT          reduce using rule 60 (expr -> ~ expr .)
    [               reduce using rule 60 (expr -> ~ expr .)
    $end            reduce using rule 60 (expr -> ~ expr .)
    }               reduce using rule 60 (expr -> ~ expr .)
    ELSE            reduce using rule 60 (expr -> ~ expr .)
    ]               reduce using rule 60 (expr -> ~ expr .)
    ,               reduce using rule 60 (expr -> ~ expr .)
    )               reduce using rule 60 (expr -> ~ expr .)
    TO              reduce using rule 60 (expr -> ~ expr .)
    :               reduce using rule 60 (expr -> ~ expr .)


state 107

    (75) expr -> ID DOUBLECOLON . ID ( args )
    ID              shift and go to state 172


state 108

    (76) expr -> ID ( . args )
    (117) args -> . empty
    (118) args -> . arg
    (119) args -> . args , arg
    (110) empty -> .
    (120) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    args                           shift and go to state 173
    empty                          shift and go to state 174
    arg                            shift and go to state 175
    expr                           shift and go to state 176
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 109

    (80) expr -> ID LEFTARROW . { struct_init_exprs }
    {               shift and go to state 177


state 110

    (78) expr -> TYPEOF expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 78 (expr -> TYPEOF expr .)
    LET             reduce using rule 78 (expr -> TYPEOF expr .)
    PRINT           reduce using rule 78 (expr -> TYPEOF expr .)
    RAW_INPUT       reduce using rule 78 (expr -> TYPEOF expr .)
    {               reduce using rule 78 (expr -> TYPEOF expr .)
    NIL             reduce using rule 78 (expr -> TYPEOF expr .)
    FALSE           reduce using rule 78 (expr -> TYPEOF expr .)
    TRUE            reduce using rule 78 (expr -> TYPEOF expr .)
    STRING          reduce using rule 78 (expr -> TYPEOF expr .)
    FLOAT           reduce using rule 78 (expr -> TYPEOF expr .)
    INT             reduce using rule 78 (expr -> TYPEOF expr .)
    (               reduce using rule 78 (expr -> TYPEOF expr .)
    !               reduce using rule 78 (expr -> TYPEOF expr .)
    ~               reduce using rule 78 (expr -> TYPEOF expr .)
    TYPEOF          reduce using rule 78 (expr -> TYPEOF expr .)
    LAMBDA          reduce using rule 78 (expr -> TYPEOF expr .)
    DEC             reduce using rule 78 (expr -> TYPEOF expr .)
    INC             reduce using rule 78 (expr -> TYPEOF expr .)
    CLASS           reduce using rule 78 (expr -> TYPEOF expr .)
    STRUCT          reduce using rule 78 (expr -> TYPEOF expr .)
    IF              reduce using rule 78 (expr -> TYPEOF expr .)
    FOR             reduce using rule 78 (expr -> TYPEOF expr .)
    WHILE           reduce using rule 78 (expr -> TYPEOF expr .)
    RETURN          reduce using rule 78 (expr -> TYPEOF expr .)
    FN              reduce using rule 78 (expr -> TYPEOF expr .)
    IMPORT          reduce using rule 78 (expr -> TYPEOF expr .)
    [               reduce using rule 78 (expr -> TYPEOF expr .)
    $end            reduce using rule 78 (expr -> TYPEOF expr .)
    }               reduce using rule 78 (expr -> TYPEOF expr .)
    ELSE            reduce using rule 78 (expr -> TYPEOF expr .)
    ]               reduce using rule 78 (expr -> TYPEOF expr .)
    ,               reduce using rule 78 (expr -> TYPEOF expr .)
    )               reduce using rule 78 (expr -> TYPEOF expr .)
    TO              reduce using rule 78 (expr -> TYPEOF expr .)
    :               reduce using rule 78 (expr -> TYPEOF expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 111

    (79) expr -> LAMBDA ( . params ) ARROW expr
    (113) params -> . empty
    (114) params -> . param
    (115) params -> . params , param
    (110) empty -> .
    (116) param -> . ID var_type
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ID              shift and go to state 181

    params                         shift and go to state 178
    empty                          shift and go to state 179
    param                          shift and go to state 180

state 112

    (86) var_assign -> DEC var .
    (108) var -> var . [ expr ]
    SEP             reduce using rule 86 (var_assign -> DEC var .)
    [               shift and go to state 150


state 113

    (109) var -> ID .
    [               reduce using rule 109 (var -> ID .)
    SEP             reduce using rule 109 (var -> ID .)


state 114

    (87) var_assign -> INC var .
    (108) var -> var . [ expr ]
    SEP             reduce using rule 87 (var_assign -> INC var .)
    [               shift and go to state 150


state 115

    (19) class_definition -> CLASS ID . { function_definitions }
    {               shift and go to state 182


state 116

    (23) struct_definition -> STRUCT ID . { struct_fields } SEP
    {               shift and go to state 183


state 117

    (100) if_statement -> IF expr . block
    (101) if_statement -> IF expr . block ELSE block
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    (111) block -> . statement
    (112) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 185
    +               shift and go to state 186
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 187
    ?               shift and go to state 74
    {               shift and go to state 189
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    ~               shift and go to state 34
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    expr                           shift and go to state 5
    block                          shift and go to state 184
    statement                      shift and go to state 188
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 118

    (103) for_statement -> FOR expr . TO expr block
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    TO              shift and go to state 190
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 119

    (102) while_statement -> WHILE expr . block
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    (111) block -> . statement
    (112) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 185
    +               shift and go to state 186
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 187
    ?               shift and go to state 74
    {               shift and go to state 189
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    ~               shift and go to state 34
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    expr                           shift and go to state 5
    block                          shift and go to state 191
    statement                      shift and go to state 188
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 120

    (85) return_statement -> RETURN expr . SEP
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             shift and go to state 192
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 121

    (34) function_definition -> FN ID . ( params ) block
    (               shift and go to state 193


state 122

    (33) import_statement -> IMPORT STRING . SEP
    SEP             shift and go to state 194


state 123

    (47) expr -> expr PERSENT expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 47 (expr -> expr PERSENT expr .)
    LET             reduce using rule 47 (expr -> expr PERSENT expr .)
    PRINT           reduce using rule 47 (expr -> expr PERSENT expr .)
    RAW_INPUT       reduce using rule 47 (expr -> expr PERSENT expr .)
    {               reduce using rule 47 (expr -> expr PERSENT expr .)
    NIL             reduce using rule 47 (expr -> expr PERSENT expr .)
    FALSE           reduce using rule 47 (expr -> expr PERSENT expr .)
    TRUE            reduce using rule 47 (expr -> expr PERSENT expr .)
    STRING          reduce using rule 47 (expr -> expr PERSENT expr .)
    FLOAT           reduce using rule 47 (expr -> expr PERSENT expr .)
    INT             reduce using rule 47 (expr -> expr PERSENT expr .)
    (               reduce using rule 47 (expr -> expr PERSENT expr .)
    !               reduce using rule 47 (expr -> expr PERSENT expr .)
    ~               reduce using rule 47 (expr -> expr PERSENT expr .)
    TYPEOF          reduce using rule 47 (expr -> expr PERSENT expr .)
    LAMBDA          reduce using rule 47 (expr -> expr PERSENT expr .)
    DEC             reduce using rule 47 (expr -> expr PERSENT expr .)
    INC             reduce using rule 47 (expr -> expr PERSENT expr .)
    CLASS           reduce using rule 47 (expr -> expr PERSENT expr .)
    STRUCT          reduce using rule 47 (expr -> expr PERSENT expr .)
    IF              reduce using rule 47 (expr -> expr PERSENT expr .)
    FOR             reduce using rule 47 (expr -> expr PERSENT expr .)
    WHILE           reduce using rule 47 (expr -> expr PERSENT expr .)
    RETURN          reduce using rule 47 (expr -> expr PERSENT expr .)
    FN              reduce using rule 47 (expr -> expr PERSENT expr .)
    IMPORT          reduce using rule 47 (expr -> expr PERSENT expr .)
    [               reduce using rule 47 (expr -> expr PERSENT expr .)
    $end            reduce using rule 47 (expr -> expr PERSENT expr .)
    }               reduce using rule 47 (expr -> expr PERSENT expr .)
    ELSE            reduce using rule 47 (expr -> expr PERSENT expr .)
    ]               reduce using rule 47 (expr -> expr PERSENT expr .)
    ,               reduce using rule 47 (expr -> expr PERSENT expr .)
    )               reduce using rule 47 (expr -> expr PERSENT expr .)
    TO              reduce using rule 47 (expr -> expr PERSENT expr .)
    :               reduce using rule 47 (expr -> expr PERSENT expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 124

    (48) expr -> expr DIV expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 48 (expr -> expr DIV expr .)
    LET             reduce using rule 48 (expr -> expr DIV expr .)
    PRINT           reduce using rule 48 (expr -> expr DIV expr .)
    RAW_INPUT       reduce using rule 48 (expr -> expr DIV expr .)
    {               reduce using rule 48 (expr -> expr DIV expr .)
    NIL             reduce using rule 48 (expr -> expr DIV expr .)
    FALSE           reduce using rule 48 (expr -> expr DIV expr .)
    TRUE            reduce using rule 48 (expr -> expr DIV expr .)
    STRING          reduce using rule 48 (expr -> expr DIV expr .)
    FLOAT           reduce using rule 48 (expr -> expr DIV expr .)
    INT             reduce using rule 48 (expr -> expr DIV expr .)
    (               reduce using rule 48 (expr -> expr DIV expr .)
    !               reduce using rule 48 (expr -> expr DIV expr .)
    ~               reduce using rule 48 (expr -> expr DIV expr .)
    TYPEOF          reduce using rule 48 (expr -> expr DIV expr .)
    LAMBDA          reduce using rule 48 (expr -> expr DIV expr .)
    DEC             reduce using rule 48 (expr -> expr DIV expr .)
    INC             reduce using rule 48 (expr -> expr DIV expr .)
    CLASS           reduce using rule 48 (expr -> expr DIV expr .)
    STRUCT          reduce using rule 48 (expr -> expr DIV expr .)
    IF              reduce using rule 48 (expr -> expr DIV expr .)
    FOR             reduce using rule 48 (expr -> expr DIV expr .)
    WHILE           reduce using rule 48 (expr -> expr DIV expr .)
    RETURN          reduce using rule 48 (expr -> expr DIV expr .)
    FN              reduce using rule 48 (expr -> expr DIV expr .)
    IMPORT          reduce using rule 48 (expr -> expr DIV expr .)
    [               reduce using rule 48 (expr -> expr DIV expr .)
    $end            reduce using rule 48 (expr -> expr DIV expr .)
    }               reduce using rule 48 (expr -> expr DIV expr .)
    ELSE            reduce using rule 48 (expr -> expr DIV expr .)
    ]               reduce using rule 48 (expr -> expr DIV expr .)
    ,               reduce using rule 48 (expr -> expr DIV expr .)
    )               reduce using rule 48 (expr -> expr DIV expr .)
    TO              reduce using rule 48 (expr -> expr DIV expr .)
    :               reduce using rule 48 (expr -> expr DIV expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 125

    (49) expr -> expr MUL expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 49 (expr -> expr MUL expr .)
    LET             reduce using rule 49 (expr -> expr MUL expr .)
    PRINT           reduce using rule 49 (expr -> expr MUL expr .)
    RAW_INPUT       reduce using rule 49 (expr -> expr MUL expr .)
    {               reduce using rule 49 (expr -> expr MUL expr .)
    NIL             reduce using rule 49 (expr -> expr MUL expr .)
    FALSE           reduce using rule 49 (expr -> expr MUL expr .)
    TRUE            reduce using rule 49 (expr -> expr MUL expr .)
    STRING          reduce using rule 49 (expr -> expr MUL expr .)
    FLOAT           reduce using rule 49 (expr -> expr MUL expr .)
    INT             reduce using rule 49 (expr -> expr MUL expr .)
    (               reduce using rule 49 (expr -> expr MUL expr .)
    !               reduce using rule 49 (expr -> expr MUL expr .)
    ~               reduce using rule 49 (expr -> expr MUL expr .)
    TYPEOF          reduce using rule 49 (expr -> expr MUL expr .)
    LAMBDA          reduce using rule 49 (expr -> expr MUL expr .)
    DEC             reduce using rule 49 (expr -> expr MUL expr .)
    INC             reduce using rule 49 (expr -> expr MUL expr .)
    CLASS           reduce using rule 49 (expr -> expr MUL expr .)
    STRUCT          reduce using rule 49 (expr -> expr MUL expr .)
    IF              reduce using rule 49 (expr -> expr MUL expr .)
    FOR             reduce using rule 49 (expr -> expr MUL expr .)
    WHILE           reduce using rule 49 (expr -> expr MUL expr .)
    RETURN          reduce using rule 49 (expr -> expr MUL expr .)
    FN              reduce using rule 49 (expr -> expr MUL expr .)
    IMPORT          reduce using rule 49 (expr -> expr MUL expr .)
    [               reduce using rule 49 (expr -> expr MUL expr .)
    $end            reduce using rule 49 (expr -> expr MUL expr .)
    }               reduce using rule 49 (expr -> expr MUL expr .)
    ELSE            reduce using rule 49 (expr -> expr MUL expr .)
    ]               reduce using rule 49 (expr -> expr MUL expr .)
    ,               reduce using rule 49 (expr -> expr MUL expr .)
    )               reduce using rule 49 (expr -> expr MUL expr .)
    TO              reduce using rule 49 (expr -> expr MUL expr .)
    :               reduce using rule 49 (expr -> expr MUL expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 126

    (50) expr -> expr SUB expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 50 (expr -> expr SUB expr .)
    LET             reduce using rule 50 (expr -> expr SUB expr .)
    PRINT           reduce using rule 50 (expr -> expr SUB expr .)
    RAW_INPUT       reduce using rule 50 (expr -> expr SUB expr .)
    {               reduce using rule 50 (expr -> expr SUB expr .)
    NIL             reduce using rule 50 (expr -> expr SUB expr .)
    FALSE           reduce using rule 50 (expr -> expr SUB expr .)
    TRUE            reduce using rule 50 (expr -> expr SUB expr .)
    STRING          reduce using rule 50 (expr -> expr SUB expr .)
    FLOAT           reduce using rule 50 (expr -> expr SUB expr .)
    INT             reduce using rule 50 (expr -> expr SUB expr .)
    (               reduce using rule 50 (expr -> expr SUB expr .)
    !               reduce using rule 50 (expr -> expr SUB expr .)
    ~               reduce using rule 50 (expr -> expr SUB expr .)
    TYPEOF          reduce using rule 50 (expr -> expr SUB expr .)
    LAMBDA          reduce using rule 50 (expr -> expr SUB expr .)
    DEC             reduce using rule 50 (expr -> expr SUB expr .)
    INC             reduce using rule 50 (expr -> expr SUB expr .)
    CLASS           reduce using rule 50 (expr -> expr SUB expr .)
    STRUCT          reduce using rule 50 (expr -> expr SUB expr .)
    IF              reduce using rule 50 (expr -> expr SUB expr .)
    FOR             reduce using rule 50 (expr -> expr SUB expr .)
    WHILE           reduce using rule 50 (expr -> expr SUB expr .)
    RETURN          reduce using rule 50 (expr -> expr SUB expr .)
    FN              reduce using rule 50 (expr -> expr SUB expr .)
    IMPORT          reduce using rule 50 (expr -> expr SUB expr .)
    [               reduce using rule 50 (expr -> expr SUB expr .)
    $end            reduce using rule 50 (expr -> expr SUB expr .)
    }               reduce using rule 50 (expr -> expr SUB expr .)
    ELSE            reduce using rule 50 (expr -> expr SUB expr .)
    ]               reduce using rule 50 (expr -> expr SUB expr .)
    ,               reduce using rule 50 (expr -> expr SUB expr .)
    )               reduce using rule 50 (expr -> expr SUB expr .)
    TO              reduce using rule 50 (expr -> expr SUB expr .)
    :               reduce using rule 50 (expr -> expr SUB expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 127

    (51) expr -> expr ADD expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 51 (expr -> expr ADD expr .)
    LET             reduce using rule 51 (expr -> expr ADD expr .)
    PRINT           reduce using rule 51 (expr -> expr ADD expr .)
    RAW_INPUT       reduce using rule 51 (expr -> expr ADD expr .)
    {               reduce using rule 51 (expr -> expr ADD expr .)
    NIL             reduce using rule 51 (expr -> expr ADD expr .)
    FALSE           reduce using rule 51 (expr -> expr ADD expr .)
    TRUE            reduce using rule 51 (expr -> expr ADD expr .)
    STRING          reduce using rule 51 (expr -> expr ADD expr .)
    FLOAT           reduce using rule 51 (expr -> expr ADD expr .)
    INT             reduce using rule 51 (expr -> expr ADD expr .)
    (               reduce using rule 51 (expr -> expr ADD expr .)
    !               reduce using rule 51 (expr -> expr ADD expr .)
    ~               reduce using rule 51 (expr -> expr ADD expr .)
    TYPEOF          reduce using rule 51 (expr -> expr ADD expr .)
    LAMBDA          reduce using rule 51 (expr -> expr ADD expr .)
    DEC             reduce using rule 51 (expr -> expr ADD expr .)
    INC             reduce using rule 51 (expr -> expr ADD expr .)
    CLASS           reduce using rule 51 (expr -> expr ADD expr .)
    STRUCT          reduce using rule 51 (expr -> expr ADD expr .)
    IF              reduce using rule 51 (expr -> expr ADD expr .)
    FOR             reduce using rule 51 (expr -> expr ADD expr .)
    WHILE           reduce using rule 51 (expr -> expr ADD expr .)
    RETURN          reduce using rule 51 (expr -> expr ADD expr .)
    FN              reduce using rule 51 (expr -> expr ADD expr .)
    IMPORT          reduce using rule 51 (expr -> expr ADD expr .)
    [               reduce using rule 51 (expr -> expr ADD expr .)
    $end            reduce using rule 51 (expr -> expr ADD expr .)
    }               reduce using rule 51 (expr -> expr ADD expr .)
    ELSE            reduce using rule 51 (expr -> expr ADD expr .)
    ]               reduce using rule 51 (expr -> expr ADD expr .)
    ,               reduce using rule 51 (expr -> expr ADD expr .)
    )               reduce using rule 51 (expr -> expr ADD expr .)
    TO              reduce using rule 51 (expr -> expr ADD expr .)
    :               reduce using rule 51 (expr -> expr ADD expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 128

    (52) expr -> expr % expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 52 (expr -> expr % expr .)
    PERSENT         reduce using rule 52 (expr -> expr % expr .)
    DIV             reduce using rule 52 (expr -> expr % expr .)
    MUL             reduce using rule 52 (expr -> expr % expr .)
    SUB             reduce using rule 52 (expr -> expr % expr .)
    ADD             reduce using rule 52 (expr -> expr % expr .)
    %               reduce using rule 52 (expr -> expr % expr .)
    /               reduce using rule 52 (expr -> expr % expr .)
    *               reduce using rule 52 (expr -> expr % expr .)
    -               reduce using rule 52 (expr -> expr % expr .)
    +               reduce using rule 52 (expr -> expr % expr .)
    |               reduce using rule 52 (expr -> expr % expr .)
    ^               reduce using rule 52 (expr -> expr % expr .)
    &               reduce using rule 52 (expr -> expr % expr .)
    SHR             reduce using rule 52 (expr -> expr % expr .)
    SHL             reduce using rule 52 (expr -> expr % expr .)
    GREATER         reduce using rule 52 (expr -> expr % expr .)
    LESS            reduce using rule 52 (expr -> expr % expr .)
    OR              reduce using rule 52 (expr -> expr % expr .)
    AND             reduce using rule 52 (expr -> expr % expr .)
    GREATEREQ       reduce using rule 52 (expr -> expr % expr .)
    LESSEQ          reduce using rule 52 (expr -> expr % expr .)
    NOTEQ           reduce using rule 52 (expr -> expr % expr .)
    EQEQ            reduce using rule 52 (expr -> expr % expr .)
    ID              reduce using rule 52 (expr -> expr % expr .)
    ?               reduce using rule 52 (expr -> expr % expr .)
    LET             reduce using rule 52 (expr -> expr % expr .)
    PRINT           reduce using rule 52 (expr -> expr % expr .)
    RAW_INPUT       reduce using rule 52 (expr -> expr % expr .)
    {               reduce using rule 52 (expr -> expr % expr .)
    NIL             reduce using rule 52 (expr -> expr % expr .)
    FALSE           reduce using rule 52 (expr -> expr % expr .)
    TRUE            reduce using rule 52 (expr -> expr % expr .)
    STRING          reduce using rule 52 (expr -> expr % expr .)
    FLOAT           reduce using rule 52 (expr -> expr % expr .)
    INT             reduce using rule 52 (expr -> expr % expr .)
    (               reduce using rule 52 (expr -> expr % expr .)
    !               reduce using rule 52 (expr -> expr % expr .)
    ~               reduce using rule 52 (expr -> expr % expr .)
    TYPEOF          reduce using rule 52 (expr -> expr % expr .)
    LAMBDA          reduce using rule 52 (expr -> expr % expr .)
    DEC             reduce using rule 52 (expr -> expr % expr .)
    INC             reduce using rule 52 (expr -> expr % expr .)
    CLASS           reduce using rule 52 (expr -> expr % expr .)
    STRUCT          reduce using rule 52 (expr -> expr % expr .)
    IF              reduce using rule 52 (expr -> expr % expr .)
    FOR             reduce using rule 52 (expr -> expr % expr .)
    WHILE           reduce using rule 52 (expr -> expr % expr .)
    RETURN          reduce using rule 52 (expr -> expr % expr .)
    FN              reduce using rule 52 (expr -> expr % expr .)
    IMPORT          reduce using rule 52 (expr -> expr % expr .)
    [               reduce using rule 52 (expr -> expr % expr .)
    $end            reduce using rule 52 (expr -> expr % expr .)
    }               reduce using rule 52 (expr -> expr % expr .)
    ELSE            reduce using rule 52 (expr -> expr % expr .)
    ]               reduce using rule 52 (expr -> expr % expr .)
    ,               reduce using rule 52 (expr -> expr % expr .)
    )               reduce using rule 52 (expr -> expr % expr .)
    TO              reduce using rule 52 (expr -> expr % expr .)
    :               reduce using rule 52 (expr -> expr % expr .)


state 129

    (53) expr -> expr / expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 53 (expr -> expr / expr .)
    PERSENT         reduce using rule 53 (expr -> expr / expr .)
    DIV             reduce using rule 53 (expr -> expr / expr .)
    MUL             reduce using rule 53 (expr -> expr / expr .)
    SUB             reduce using rule 53 (expr -> expr / expr .)
    ADD             reduce using rule 53 (expr -> expr / expr .)
    %               reduce using rule 53 (expr -> expr / expr .)
    /               reduce using rule 53 (expr -> expr / expr .)
    *               reduce using rule 53 (expr -> expr / expr .)
    -               reduce using rule 53 (expr -> expr / expr .)
    +               reduce using rule 53 (expr -> expr / expr .)
    |               reduce using rule 53 (expr -> expr / expr .)
    ^               reduce using rule 53 (expr -> expr / expr .)
    &               reduce using rule 53 (expr -> expr / expr .)
    SHR             reduce using rule 53 (expr -> expr / expr .)
    SHL             reduce using rule 53 (expr -> expr / expr .)
    GREATER         reduce using rule 53 (expr -> expr / expr .)
    LESS            reduce using rule 53 (expr -> expr / expr .)
    OR              reduce using rule 53 (expr -> expr / expr .)
    AND             reduce using rule 53 (expr -> expr / expr .)
    GREATEREQ       reduce using rule 53 (expr -> expr / expr .)
    LESSEQ          reduce using rule 53 (expr -> expr / expr .)
    NOTEQ           reduce using rule 53 (expr -> expr / expr .)
    EQEQ            reduce using rule 53 (expr -> expr / expr .)
    ID              reduce using rule 53 (expr -> expr / expr .)
    ?               reduce using rule 53 (expr -> expr / expr .)
    LET             reduce using rule 53 (expr -> expr / expr .)
    PRINT           reduce using rule 53 (expr -> expr / expr .)
    RAW_INPUT       reduce using rule 53 (expr -> expr / expr .)
    {               reduce using rule 53 (expr -> expr / expr .)
    NIL             reduce using rule 53 (expr -> expr / expr .)
    FALSE           reduce using rule 53 (expr -> expr / expr .)
    TRUE            reduce using rule 53 (expr -> expr / expr .)
    STRING          reduce using rule 53 (expr -> expr / expr .)
    FLOAT           reduce using rule 53 (expr -> expr / expr .)
    INT             reduce using rule 53 (expr -> expr / expr .)
    (               reduce using rule 53 (expr -> expr / expr .)
    !               reduce using rule 53 (expr -> expr / expr .)
    ~               reduce using rule 53 (expr -> expr / expr .)
    TYPEOF          reduce using rule 53 (expr -> expr / expr .)
    LAMBDA          reduce using rule 53 (expr -> expr / expr .)
    DEC             reduce using rule 53 (expr -> expr / expr .)
    INC             reduce using rule 53 (expr -> expr / expr .)
    CLASS           reduce using rule 53 (expr -> expr / expr .)
    STRUCT          reduce using rule 53 (expr -> expr / expr .)
    IF              reduce using rule 53 (expr -> expr / expr .)
    FOR             reduce using rule 53 (expr -> expr / expr .)
    WHILE           reduce using rule 53 (expr -> expr / expr .)
    RETURN          reduce using rule 53 (expr -> expr / expr .)
    FN              reduce using rule 53 (expr -> expr / expr .)
    IMPORT          reduce using rule 53 (expr -> expr / expr .)
    [               reduce using rule 53 (expr -> expr / expr .)
    $end            reduce using rule 53 (expr -> expr / expr .)
    }               reduce using rule 53 (expr -> expr / expr .)
    ELSE            reduce using rule 53 (expr -> expr / expr .)
    ]               reduce using rule 53 (expr -> expr / expr .)
    ,               reduce using rule 53 (expr -> expr / expr .)
    )               reduce using rule 53 (expr -> expr / expr .)
    TO              reduce using rule 53 (expr -> expr / expr .)
    :               reduce using rule 53 (expr -> expr / expr .)


state 130

    (54) expr -> expr * expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 54 (expr -> expr * expr .)
    PERSENT         reduce using rule 54 (expr -> expr * expr .)
    DIV             reduce using rule 54 (expr -> expr * expr .)
    MUL             reduce using rule 54 (expr -> expr * expr .)
    SUB             reduce using rule 54 (expr -> expr * expr .)
    ADD             reduce using rule 54 (expr -> expr * expr .)
    %               reduce using rule 54 (expr -> expr * expr .)
    /               reduce using rule 54 (expr -> expr * expr .)
    *               reduce using rule 54 (expr -> expr * expr .)
    -               reduce using rule 54 (expr -> expr * expr .)
    +               reduce using rule 54 (expr -> expr * expr .)
    |               reduce using rule 54 (expr -> expr * expr .)
    ^               reduce using rule 54 (expr -> expr * expr .)
    &               reduce using rule 54 (expr -> expr * expr .)
    SHR             reduce using rule 54 (expr -> expr * expr .)
    SHL             reduce using rule 54 (expr -> expr * expr .)
    GREATER         reduce using rule 54 (expr -> expr * expr .)
    LESS            reduce using rule 54 (expr -> expr * expr .)
    OR              reduce using rule 54 (expr -> expr * expr .)
    AND             reduce using rule 54 (expr -> expr * expr .)
    GREATEREQ       reduce using rule 54 (expr -> expr * expr .)
    LESSEQ          reduce using rule 54 (expr -> expr * expr .)
    NOTEQ           reduce using rule 54 (expr -> expr * expr .)
    EQEQ            reduce using rule 54 (expr -> expr * expr .)
    ID              reduce using rule 54 (expr -> expr * expr .)
    ?               reduce using rule 54 (expr -> expr * expr .)
    LET             reduce using rule 54 (expr -> expr * expr .)
    PRINT           reduce using rule 54 (expr -> expr * expr .)
    RAW_INPUT       reduce using rule 54 (expr -> expr * expr .)
    {               reduce using rule 54 (expr -> expr * expr .)
    NIL             reduce using rule 54 (expr -> expr * expr .)
    FALSE           reduce using rule 54 (expr -> expr * expr .)
    TRUE            reduce using rule 54 (expr -> expr * expr .)
    STRING          reduce using rule 54 (expr -> expr * expr .)
    FLOAT           reduce using rule 54 (expr -> expr * expr .)
    INT             reduce using rule 54 (expr -> expr * expr .)
    (               reduce using rule 54 (expr -> expr * expr .)
    !               reduce using rule 54 (expr -> expr * expr .)
    ~               reduce using rule 54 (expr -> expr * expr .)
    TYPEOF          reduce using rule 54 (expr -> expr * expr .)
    LAMBDA          reduce using rule 54 (expr -> expr * expr .)
    DEC             reduce using rule 54 (expr -> expr * expr .)
    INC             reduce using rule 54 (expr -> expr * expr .)
    CLASS           reduce using rule 54 (expr -> expr * expr .)
    STRUCT          reduce using rule 54 (expr -> expr * expr .)
    IF              reduce using rule 54 (expr -> expr * expr .)
    FOR             reduce using rule 54 (expr -> expr * expr .)
    WHILE           reduce using rule 54 (expr -> expr * expr .)
    RETURN          reduce using rule 54 (expr -> expr * expr .)
    FN              reduce using rule 54 (expr -> expr * expr .)
    IMPORT          reduce using rule 54 (expr -> expr * expr .)
    [               reduce using rule 54 (expr -> expr * expr .)
    $end            reduce using rule 54 (expr -> expr * expr .)
    }               reduce using rule 54 (expr -> expr * expr .)
    ELSE            reduce using rule 54 (expr -> expr * expr .)
    ]               reduce using rule 54 (expr -> expr * expr .)
    ,               reduce using rule 54 (expr -> expr * expr .)
    )               reduce using rule 54 (expr -> expr * expr .)
    TO              reduce using rule 54 (expr -> expr * expr .)
    :               reduce using rule 54 (expr -> expr * expr .)


state 131

    (55) expr -> expr - expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 55 (expr -> expr - expr .)
    PERSENT         reduce using rule 55 (expr -> expr - expr .)
    DIV             reduce using rule 55 (expr -> expr - expr .)
    MUL             reduce using rule 55 (expr -> expr - expr .)
    SUB             reduce using rule 55 (expr -> expr - expr .)
    ADD             reduce using rule 55 (expr -> expr - expr .)
    -               reduce using rule 55 (expr -> expr - expr .)
    +               reduce using rule 55 (expr -> expr - expr .)
    |               reduce using rule 55 (expr -> expr - expr .)
    ^               reduce using rule 55 (expr -> expr - expr .)
    &               reduce using rule 55 (expr -> expr - expr .)
    SHR             reduce using rule 55 (expr -> expr - expr .)
    SHL             reduce using rule 55 (expr -> expr - expr .)
    GREATER         reduce using rule 55 (expr -> expr - expr .)
    LESS            reduce using rule 55 (expr -> expr - expr .)
    OR              reduce using rule 55 (expr -> expr - expr .)
    AND             reduce using rule 55 (expr -> expr - expr .)
    GREATEREQ       reduce using rule 55 (expr -> expr - expr .)
    LESSEQ          reduce using rule 55 (expr -> expr - expr .)
    NOTEQ           reduce using rule 55 (expr -> expr - expr .)
    EQEQ            reduce using rule 55 (expr -> expr - expr .)
    ID              reduce using rule 55 (expr -> expr - expr .)
    ?               reduce using rule 55 (expr -> expr - expr .)
    LET             reduce using rule 55 (expr -> expr - expr .)
    PRINT           reduce using rule 55 (expr -> expr - expr .)
    RAW_INPUT       reduce using rule 55 (expr -> expr - expr .)
    {               reduce using rule 55 (expr -> expr - expr .)
    NIL             reduce using rule 55 (expr -> expr - expr .)
    FALSE           reduce using rule 55 (expr -> expr - expr .)
    TRUE            reduce using rule 55 (expr -> expr - expr .)
    STRING          reduce using rule 55 (expr -> expr - expr .)
    FLOAT           reduce using rule 55 (expr -> expr - expr .)
    INT             reduce using rule 55 (expr -> expr - expr .)
    (               reduce using rule 55 (expr -> expr - expr .)
    !               reduce using rule 55 (expr -> expr - expr .)
    ~               reduce using rule 55 (expr -> expr - expr .)
    TYPEOF          reduce using rule 55 (expr -> expr - expr .)
    LAMBDA          reduce using rule 55 (expr -> expr - expr .)
    DEC             reduce using rule 55 (expr -> expr - expr .)
    INC             reduce using rule 55 (expr -> expr - expr .)
    CLASS           reduce using rule 55 (expr -> expr - expr .)
    STRUCT          reduce using rule 55 (expr -> expr - expr .)
    IF              reduce using rule 55 (expr -> expr - expr .)
    FOR             reduce using rule 55 (expr -> expr - expr .)
    WHILE           reduce using rule 55 (expr -> expr - expr .)
    RETURN          reduce using rule 55 (expr -> expr - expr .)
    FN              reduce using rule 55 (expr -> expr - expr .)
    IMPORT          reduce using rule 55 (expr -> expr - expr .)
    [               reduce using rule 55 (expr -> expr - expr .)
    $end            reduce using rule 55 (expr -> expr - expr .)
    }               reduce using rule 55 (expr -> expr - expr .)
    ELSE            reduce using rule 55 (expr -> expr - expr .)
    ]               reduce using rule 55 (expr -> expr - expr .)
    ,               reduce using rule 55 (expr -> expr - expr .)
    )               reduce using rule 55 (expr -> expr - expr .)
    TO              reduce using rule 55 (expr -> expr - expr .)
    :               reduce using rule 55 (expr -> expr - expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57


state 132

    (56) expr -> expr + expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 56 (expr -> expr + expr .)
    PERSENT         reduce using rule 56 (expr -> expr + expr .)
    DIV             reduce using rule 56 (expr -> expr + expr .)
    MUL             reduce using rule 56 (expr -> expr + expr .)
    SUB             reduce using rule 56 (expr -> expr + expr .)
    ADD             reduce using rule 56 (expr -> expr + expr .)
    -               reduce using rule 56 (expr -> expr + expr .)
    +               reduce using rule 56 (expr -> expr + expr .)
    |               reduce using rule 56 (expr -> expr + expr .)
    ^               reduce using rule 56 (expr -> expr + expr .)
    &               reduce using rule 56 (expr -> expr + expr .)
    SHR             reduce using rule 56 (expr -> expr + expr .)
    SHL             reduce using rule 56 (expr -> expr + expr .)
    GREATER         reduce using rule 56 (expr -> expr + expr .)
    LESS            reduce using rule 56 (expr -> expr + expr .)
    OR              reduce using rule 56 (expr -> expr + expr .)
    AND             reduce using rule 56 (expr -> expr + expr .)
    GREATEREQ       reduce using rule 56 (expr -> expr + expr .)
    LESSEQ          reduce using rule 56 (expr -> expr + expr .)
    NOTEQ           reduce using rule 56 (expr -> expr + expr .)
    EQEQ            reduce using rule 56 (expr -> expr + expr .)
    ID              reduce using rule 56 (expr -> expr + expr .)
    ?               reduce using rule 56 (expr -> expr + expr .)
    LET             reduce using rule 56 (expr -> expr + expr .)
    PRINT           reduce using rule 56 (expr -> expr + expr .)
    RAW_INPUT       reduce using rule 56 (expr -> expr + expr .)
    {               reduce using rule 56 (expr -> expr + expr .)
    NIL             reduce using rule 56 (expr -> expr + expr .)
    FALSE           reduce using rule 56 (expr -> expr + expr .)
    TRUE            reduce using rule 56 (expr -> expr + expr .)
    STRING          reduce using rule 56 (expr -> expr + expr .)
    FLOAT           reduce using rule 56 (expr -> expr + expr .)
    INT             reduce using rule 56 (expr -> expr + expr .)
    (               reduce using rule 56 (expr -> expr + expr .)
    !               reduce using rule 56 (expr -> expr + expr .)
    ~               reduce using rule 56 (expr -> expr + expr .)
    TYPEOF          reduce using rule 56 (expr -> expr + expr .)
    LAMBDA          reduce using rule 56 (expr -> expr + expr .)
    DEC             reduce using rule 56 (expr -> expr + expr .)
    INC             reduce using rule 56 (expr -> expr + expr .)
    CLASS           reduce using rule 56 (expr -> expr + expr .)
    STRUCT          reduce using rule 56 (expr -> expr + expr .)
    IF              reduce using rule 56 (expr -> expr + expr .)
    FOR             reduce using rule 56 (expr -> expr + expr .)
    WHILE           reduce using rule 56 (expr -> expr + expr .)
    RETURN          reduce using rule 56 (expr -> expr + expr .)
    FN              reduce using rule 56 (expr -> expr + expr .)
    IMPORT          reduce using rule 56 (expr -> expr + expr .)
    [               reduce using rule 56 (expr -> expr + expr .)
    $end            reduce using rule 56 (expr -> expr + expr .)
    }               reduce using rule 56 (expr -> expr + expr .)
    ELSE            reduce using rule 56 (expr -> expr + expr .)
    ]               reduce using rule 56 (expr -> expr + expr .)
    ,               reduce using rule 56 (expr -> expr + expr .)
    )               reduce using rule 56 (expr -> expr + expr .)
    TO              reduce using rule 56 (expr -> expr + expr .)
    :               reduce using rule 56 (expr -> expr + expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57


state 133

    (61) expr -> expr | expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 61 (expr -> expr | expr .)
    PERSENT         reduce using rule 61 (expr -> expr | expr .)
    DIV             reduce using rule 61 (expr -> expr | expr .)
    MUL             reduce using rule 61 (expr -> expr | expr .)
    SUB             reduce using rule 61 (expr -> expr | expr .)
    ADD             reduce using rule 61 (expr -> expr | expr .)
    |               reduce using rule 61 (expr -> expr | expr .)
    OR              reduce using rule 61 (expr -> expr | expr .)
    AND             reduce using rule 61 (expr -> expr | expr .)
    ID              reduce using rule 61 (expr -> expr | expr .)
    ?               reduce using rule 61 (expr -> expr | expr .)
    LET             reduce using rule 61 (expr -> expr | expr .)
    PRINT           reduce using rule 61 (expr -> expr | expr .)
    RAW_INPUT       reduce using rule 61 (expr -> expr | expr .)
    {               reduce using rule 61 (expr -> expr | expr .)
    NIL             reduce using rule 61 (expr -> expr | expr .)
    FALSE           reduce using rule 61 (expr -> expr | expr .)
    TRUE            reduce using rule 61 (expr -> expr | expr .)
    STRING          reduce using rule 61 (expr -> expr | expr .)
    FLOAT           reduce using rule 61 (expr -> expr | expr .)
    INT             reduce using rule 61 (expr -> expr | expr .)
    (               reduce using rule 61 (expr -> expr | expr .)
    !               reduce using rule 61 (expr -> expr | expr .)
    ~               reduce using rule 61 (expr -> expr | expr .)
    TYPEOF          reduce using rule 61 (expr -> expr | expr .)
    LAMBDA          reduce using rule 61 (expr -> expr | expr .)
    DEC             reduce using rule 61 (expr -> expr | expr .)
    INC             reduce using rule 61 (expr -> expr | expr .)
    CLASS           reduce using rule 61 (expr -> expr | expr .)
    STRUCT          reduce using rule 61 (expr -> expr | expr .)
    IF              reduce using rule 61 (expr -> expr | expr .)
    FOR             reduce using rule 61 (expr -> expr | expr .)
    WHILE           reduce using rule 61 (expr -> expr | expr .)
    RETURN          reduce using rule 61 (expr -> expr | expr .)
    FN              reduce using rule 61 (expr -> expr | expr .)
    IMPORT          reduce using rule 61 (expr -> expr | expr .)
    [               reduce using rule 61 (expr -> expr | expr .)
    $end            reduce using rule 61 (expr -> expr | expr .)
    }               reduce using rule 61 (expr -> expr | expr .)
    ELSE            reduce using rule 61 (expr -> expr | expr .)
    ]               reduce using rule 61 (expr -> expr | expr .)
    ,               reduce using rule 61 (expr -> expr | expr .)
    )               reduce using rule 61 (expr -> expr | expr .)
    TO              reduce using rule 61 (expr -> expr | expr .)
    :               reduce using rule 61 (expr -> expr | expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72


state 134

    (62) expr -> expr ^ expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 62 (expr -> expr ^ expr .)
    PERSENT         reduce using rule 62 (expr -> expr ^ expr .)
    DIV             reduce using rule 62 (expr -> expr ^ expr .)
    MUL             reduce using rule 62 (expr -> expr ^ expr .)
    SUB             reduce using rule 62 (expr -> expr ^ expr .)
    ADD             reduce using rule 62 (expr -> expr ^ expr .)
    |               reduce using rule 62 (expr -> expr ^ expr .)
    ^               reduce using rule 62 (expr -> expr ^ expr .)
    OR              reduce using rule 62 (expr -> expr ^ expr .)
    AND             reduce using rule 62 (expr -> expr ^ expr .)
    ID              reduce using rule 62 (expr -> expr ^ expr .)
    ?               reduce using rule 62 (expr -> expr ^ expr .)
    LET             reduce using rule 62 (expr -> expr ^ expr .)
    PRINT           reduce using rule 62 (expr -> expr ^ expr .)
    RAW_INPUT       reduce using rule 62 (expr -> expr ^ expr .)
    {               reduce using rule 62 (expr -> expr ^ expr .)
    NIL             reduce using rule 62 (expr -> expr ^ expr .)
    FALSE           reduce using rule 62 (expr -> expr ^ expr .)
    TRUE            reduce using rule 62 (expr -> expr ^ expr .)
    STRING          reduce using rule 62 (expr -> expr ^ expr .)
    FLOAT           reduce using rule 62 (expr -> expr ^ expr .)
    INT             reduce using rule 62 (expr -> expr ^ expr .)
    (               reduce using rule 62 (expr -> expr ^ expr .)
    !               reduce using rule 62 (expr -> expr ^ expr .)
    ~               reduce using rule 62 (expr -> expr ^ expr .)
    TYPEOF          reduce using rule 62 (expr -> expr ^ expr .)
    LAMBDA          reduce using rule 62 (expr -> expr ^ expr .)
    DEC             reduce using rule 62 (expr -> expr ^ expr .)
    INC             reduce using rule 62 (expr -> expr ^ expr .)
    CLASS           reduce using rule 62 (expr -> expr ^ expr .)
    STRUCT          reduce using rule 62 (expr -> expr ^ expr .)
    IF              reduce using rule 62 (expr -> expr ^ expr .)
    FOR             reduce using rule 62 (expr -> expr ^ expr .)
    WHILE           reduce using rule 62 (expr -> expr ^ expr .)
    RETURN          reduce using rule 62 (expr -> expr ^ expr .)
    FN              reduce using rule 62 (expr -> expr ^ expr .)
    IMPORT          reduce using rule 62 (expr -> expr ^ expr .)
    [               reduce using rule 62 (expr -> expr ^ expr .)
    $end            reduce using rule 62 (expr -> expr ^ expr .)
    }               reduce using rule 62 (expr -> expr ^ expr .)
    ELSE            reduce using rule 62 (expr -> expr ^ expr .)
    ]               reduce using rule 62 (expr -> expr ^ expr .)
    ,               reduce using rule 62 (expr -> expr ^ expr .)
    )               reduce using rule 62 (expr -> expr ^ expr .)
    TO              reduce using rule 62 (expr -> expr ^ expr .)
    :               reduce using rule 62 (expr -> expr ^ expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72


state 135

    (63) expr -> expr & expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 63 (expr -> expr & expr .)
    PERSENT         reduce using rule 63 (expr -> expr & expr .)
    DIV             reduce using rule 63 (expr -> expr & expr .)
    MUL             reduce using rule 63 (expr -> expr & expr .)
    SUB             reduce using rule 63 (expr -> expr & expr .)
    ADD             reduce using rule 63 (expr -> expr & expr .)
    |               reduce using rule 63 (expr -> expr & expr .)
    ^               reduce using rule 63 (expr -> expr & expr .)
    &               reduce using rule 63 (expr -> expr & expr .)
    OR              reduce using rule 63 (expr -> expr & expr .)
    AND             reduce using rule 63 (expr -> expr & expr .)
    ID              reduce using rule 63 (expr -> expr & expr .)
    ?               reduce using rule 63 (expr -> expr & expr .)
    LET             reduce using rule 63 (expr -> expr & expr .)
    PRINT           reduce using rule 63 (expr -> expr & expr .)
    RAW_INPUT       reduce using rule 63 (expr -> expr & expr .)
    {               reduce using rule 63 (expr -> expr & expr .)
    NIL             reduce using rule 63 (expr -> expr & expr .)
    FALSE           reduce using rule 63 (expr -> expr & expr .)
    TRUE            reduce using rule 63 (expr -> expr & expr .)
    STRING          reduce using rule 63 (expr -> expr & expr .)
    FLOAT           reduce using rule 63 (expr -> expr & expr .)
    INT             reduce using rule 63 (expr -> expr & expr .)
    (               reduce using rule 63 (expr -> expr & expr .)
    !               reduce using rule 63 (expr -> expr & expr .)
    ~               reduce using rule 63 (expr -> expr & expr .)
    TYPEOF          reduce using rule 63 (expr -> expr & expr .)
    LAMBDA          reduce using rule 63 (expr -> expr & expr .)
    DEC             reduce using rule 63 (expr -> expr & expr .)
    INC             reduce using rule 63 (expr -> expr & expr .)
    CLASS           reduce using rule 63 (expr -> expr & expr .)
    STRUCT          reduce using rule 63 (expr -> expr & expr .)
    IF              reduce using rule 63 (expr -> expr & expr .)
    FOR             reduce using rule 63 (expr -> expr & expr .)
    WHILE           reduce using rule 63 (expr -> expr & expr .)
    RETURN          reduce using rule 63 (expr -> expr & expr .)
    FN              reduce using rule 63 (expr -> expr & expr .)
    IMPORT          reduce using rule 63 (expr -> expr & expr .)
    [               reduce using rule 63 (expr -> expr & expr .)
    $end            reduce using rule 63 (expr -> expr & expr .)
    }               reduce using rule 63 (expr -> expr & expr .)
    ELSE            reduce using rule 63 (expr -> expr & expr .)
    ]               reduce using rule 63 (expr -> expr & expr .)
    ,               reduce using rule 63 (expr -> expr & expr .)
    )               reduce using rule 63 (expr -> expr & expr .)
    TO              reduce using rule 63 (expr -> expr & expr .)
    :               reduce using rule 63 (expr -> expr & expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72


state 136

    (64) expr -> expr SHR expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 64 (expr -> expr SHR expr .)
    PERSENT         reduce using rule 64 (expr -> expr SHR expr .)
    DIV             reduce using rule 64 (expr -> expr SHR expr .)
    MUL             reduce using rule 64 (expr -> expr SHR expr .)
    SUB             reduce using rule 64 (expr -> expr SHR expr .)
    ADD             reduce using rule 64 (expr -> expr SHR expr .)
    |               reduce using rule 64 (expr -> expr SHR expr .)
    ^               reduce using rule 64 (expr -> expr SHR expr .)
    &               reduce using rule 64 (expr -> expr SHR expr .)
    SHR             reduce using rule 64 (expr -> expr SHR expr .)
    SHL             reduce using rule 64 (expr -> expr SHR expr .)
    GREATER         reduce using rule 64 (expr -> expr SHR expr .)
    LESS            reduce using rule 64 (expr -> expr SHR expr .)
    OR              reduce using rule 64 (expr -> expr SHR expr .)
    AND             reduce using rule 64 (expr -> expr SHR expr .)
    GREATEREQ       reduce using rule 64 (expr -> expr SHR expr .)
    LESSEQ          reduce using rule 64 (expr -> expr SHR expr .)
    NOTEQ           reduce using rule 64 (expr -> expr SHR expr .)
    EQEQ            reduce using rule 64 (expr -> expr SHR expr .)
    ID              reduce using rule 64 (expr -> expr SHR expr .)
    ?               reduce using rule 64 (expr -> expr SHR expr .)
    LET             reduce using rule 64 (expr -> expr SHR expr .)
    PRINT           reduce using rule 64 (expr -> expr SHR expr .)
    RAW_INPUT       reduce using rule 64 (expr -> expr SHR expr .)
    {               reduce using rule 64 (expr -> expr SHR expr .)
    NIL             reduce using rule 64 (expr -> expr SHR expr .)
    FALSE           reduce using rule 64 (expr -> expr SHR expr .)
    TRUE            reduce using rule 64 (expr -> expr SHR expr .)
    STRING          reduce using rule 64 (expr -> expr SHR expr .)
    FLOAT           reduce using rule 64 (expr -> expr SHR expr .)
    INT             reduce using rule 64 (expr -> expr SHR expr .)
    (               reduce using rule 64 (expr -> expr SHR expr .)
    !               reduce using rule 64 (expr -> expr SHR expr .)
    ~               reduce using rule 64 (expr -> expr SHR expr .)
    TYPEOF          reduce using rule 64 (expr -> expr SHR expr .)
    LAMBDA          reduce using rule 64 (expr -> expr SHR expr .)
    DEC             reduce using rule 64 (expr -> expr SHR expr .)
    INC             reduce using rule 64 (expr -> expr SHR expr .)
    CLASS           reduce using rule 64 (expr -> expr SHR expr .)
    STRUCT          reduce using rule 64 (expr -> expr SHR expr .)
    IF              reduce using rule 64 (expr -> expr SHR expr .)
    FOR             reduce using rule 64 (expr -> expr SHR expr .)
    WHILE           reduce using rule 64 (expr -> expr SHR expr .)
    RETURN          reduce using rule 64 (expr -> expr SHR expr .)
    FN              reduce using rule 64 (expr -> expr SHR expr .)
    IMPORT          reduce using rule 64 (expr -> expr SHR expr .)
    [               reduce using rule 64 (expr -> expr SHR expr .)
    $end            reduce using rule 64 (expr -> expr SHR expr .)
    }               reduce using rule 64 (expr -> expr SHR expr .)
    ELSE            reduce using rule 64 (expr -> expr SHR expr .)
    ]               reduce using rule 64 (expr -> expr SHR expr .)
    ,               reduce using rule 64 (expr -> expr SHR expr .)
    )               reduce using rule 64 (expr -> expr SHR expr .)
    TO              reduce using rule 64 (expr -> expr SHR expr .)
    :               reduce using rule 64 (expr -> expr SHR expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 137

    (65) expr -> expr SHL expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 65 (expr -> expr SHL expr .)
    PERSENT         reduce using rule 65 (expr -> expr SHL expr .)
    DIV             reduce using rule 65 (expr -> expr SHL expr .)
    MUL             reduce using rule 65 (expr -> expr SHL expr .)
    SUB             reduce using rule 65 (expr -> expr SHL expr .)
    ADD             reduce using rule 65 (expr -> expr SHL expr .)
    |               reduce using rule 65 (expr -> expr SHL expr .)
    ^               reduce using rule 65 (expr -> expr SHL expr .)
    &               reduce using rule 65 (expr -> expr SHL expr .)
    SHR             reduce using rule 65 (expr -> expr SHL expr .)
    SHL             reduce using rule 65 (expr -> expr SHL expr .)
    GREATER         reduce using rule 65 (expr -> expr SHL expr .)
    LESS            reduce using rule 65 (expr -> expr SHL expr .)
    OR              reduce using rule 65 (expr -> expr SHL expr .)
    AND             reduce using rule 65 (expr -> expr SHL expr .)
    GREATEREQ       reduce using rule 65 (expr -> expr SHL expr .)
    LESSEQ          reduce using rule 65 (expr -> expr SHL expr .)
    NOTEQ           reduce using rule 65 (expr -> expr SHL expr .)
    EQEQ            reduce using rule 65 (expr -> expr SHL expr .)
    ID              reduce using rule 65 (expr -> expr SHL expr .)
    ?               reduce using rule 65 (expr -> expr SHL expr .)
    LET             reduce using rule 65 (expr -> expr SHL expr .)
    PRINT           reduce using rule 65 (expr -> expr SHL expr .)
    RAW_INPUT       reduce using rule 65 (expr -> expr SHL expr .)
    {               reduce using rule 65 (expr -> expr SHL expr .)
    NIL             reduce using rule 65 (expr -> expr SHL expr .)
    FALSE           reduce using rule 65 (expr -> expr SHL expr .)
    TRUE            reduce using rule 65 (expr -> expr SHL expr .)
    STRING          reduce using rule 65 (expr -> expr SHL expr .)
    FLOAT           reduce using rule 65 (expr -> expr SHL expr .)
    INT             reduce using rule 65 (expr -> expr SHL expr .)
    (               reduce using rule 65 (expr -> expr SHL expr .)
    !               reduce using rule 65 (expr -> expr SHL expr .)
    ~               reduce using rule 65 (expr -> expr SHL expr .)
    TYPEOF          reduce using rule 65 (expr -> expr SHL expr .)
    LAMBDA          reduce using rule 65 (expr -> expr SHL expr .)
    DEC             reduce using rule 65 (expr -> expr SHL expr .)
    INC             reduce using rule 65 (expr -> expr SHL expr .)
    CLASS           reduce using rule 65 (expr -> expr SHL expr .)
    STRUCT          reduce using rule 65 (expr -> expr SHL expr .)
    IF              reduce using rule 65 (expr -> expr SHL expr .)
    FOR             reduce using rule 65 (expr -> expr SHL expr .)
    WHILE           reduce using rule 65 (expr -> expr SHL expr .)
    RETURN          reduce using rule 65 (expr -> expr SHL expr .)
    FN              reduce using rule 65 (expr -> expr SHL expr .)
    IMPORT          reduce using rule 65 (expr -> expr SHL expr .)
    [               reduce using rule 65 (expr -> expr SHL expr .)
    $end            reduce using rule 65 (expr -> expr SHL expr .)
    }               reduce using rule 65 (expr -> expr SHL expr .)
    ELSE            reduce using rule 65 (expr -> expr SHL expr .)
    ]               reduce using rule 65 (expr -> expr SHL expr .)
    ,               reduce using rule 65 (expr -> expr SHL expr .)
    )               reduce using rule 65 (expr -> expr SHL expr .)
    TO              reduce using rule 65 (expr -> expr SHL expr .)
    :               reduce using rule 65 (expr -> expr SHL expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59


state 138

    (66) expr -> expr GREATER expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 66 (expr -> expr GREATER expr .)
    PERSENT         reduce using rule 66 (expr -> expr GREATER expr .)
    DIV             reduce using rule 66 (expr -> expr GREATER expr .)
    MUL             reduce using rule 66 (expr -> expr GREATER expr .)
    SUB             reduce using rule 66 (expr -> expr GREATER expr .)
    ADD             reduce using rule 66 (expr -> expr GREATER expr .)
    |               reduce using rule 66 (expr -> expr GREATER expr .)
    ^               reduce using rule 66 (expr -> expr GREATER expr .)
    &               reduce using rule 66 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 66 (expr -> expr GREATER expr .)
    LESS            reduce using rule 66 (expr -> expr GREATER expr .)
    OR              reduce using rule 66 (expr -> expr GREATER expr .)
    AND             reduce using rule 66 (expr -> expr GREATER expr .)
    GREATEREQ       reduce using rule 66 (expr -> expr GREATER expr .)
    LESSEQ          reduce using rule 66 (expr -> expr GREATER expr .)
    NOTEQ           reduce using rule 66 (expr -> expr GREATER expr .)
    EQEQ            reduce using rule 66 (expr -> expr GREATER expr .)
    ID              reduce using rule 66 (expr -> expr GREATER expr .)
    ?               reduce using rule 66 (expr -> expr GREATER expr .)
    LET             reduce using rule 66 (expr -> expr GREATER expr .)
    PRINT           reduce using rule 66 (expr -> expr GREATER expr .)
    RAW_INPUT       reduce using rule 66 (expr -> expr GREATER expr .)
    {               reduce using rule 66 (expr -> expr GREATER expr .)
    NIL             reduce using rule 66 (expr -> expr GREATER expr .)
    FALSE           reduce using rule 66 (expr -> expr GREATER expr .)
    TRUE            reduce using rule 66 (expr -> expr GREATER expr .)
    STRING          reduce using rule 66 (expr -> expr GREATER expr .)
    FLOAT           reduce using rule 66 (expr -> expr GREATER expr .)
    INT             reduce using rule 66 (expr -> expr GREATER expr .)
    (               reduce using rule 66 (expr -> expr GREATER expr .)
    !               reduce using rule 66 (expr -> expr GREATER expr .)
    ~               reduce using rule 66 (expr -> expr GREATER expr .)
    TYPEOF          reduce using rule 66 (expr -> expr GREATER expr .)
    LAMBDA          reduce using rule 66 (expr -> expr GREATER expr .)
    DEC             reduce using rule 66 (expr -> expr GREATER expr .)
    INC             reduce using rule 66 (expr -> expr GREATER expr .)
    CLASS           reduce using rule 66 (expr -> expr GREATER expr .)
    STRUCT          reduce using rule 66 (expr -> expr GREATER expr .)
    IF              reduce using rule 66 (expr -> expr GREATER expr .)
    FOR             reduce using rule 66 (expr -> expr GREATER expr .)
    WHILE           reduce using rule 66 (expr -> expr GREATER expr .)
    RETURN          reduce using rule 66 (expr -> expr GREATER expr .)
    FN              reduce using rule 66 (expr -> expr GREATER expr .)
    IMPORT          reduce using rule 66 (expr -> expr GREATER expr .)
    [               reduce using rule 66 (expr -> expr GREATER expr .)
    $end            reduce using rule 66 (expr -> expr GREATER expr .)
    }               reduce using rule 66 (expr -> expr GREATER expr .)
    ELSE            reduce using rule 66 (expr -> expr GREATER expr .)
    ]               reduce using rule 66 (expr -> expr GREATER expr .)
    ,               reduce using rule 66 (expr -> expr GREATER expr .)
    )               reduce using rule 66 (expr -> expr GREATER expr .)
    TO              reduce using rule 66 (expr -> expr GREATER expr .)
    :               reduce using rule 66 (expr -> expr GREATER expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    SHR             shift and go to state 63
    SHL             shift and go to state 64


state 139

    (67) expr -> expr LESS expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 67 (expr -> expr LESS expr .)
    PERSENT         reduce using rule 67 (expr -> expr LESS expr .)
    DIV             reduce using rule 67 (expr -> expr LESS expr .)
    MUL             reduce using rule 67 (expr -> expr LESS expr .)
    SUB             reduce using rule 67 (expr -> expr LESS expr .)
    ADD             reduce using rule 67 (expr -> expr LESS expr .)
    |               reduce using rule 67 (expr -> expr LESS expr .)
    ^               reduce using rule 67 (expr -> expr LESS expr .)
    &               reduce using rule 67 (expr -> expr LESS expr .)
    GREATER         reduce using rule 67 (expr -> expr LESS expr .)
    LESS            reduce using rule 67 (expr -> expr LESS expr .)
    OR              reduce using rule 67 (expr -> expr LESS expr .)
    AND             reduce using rule 67 (expr -> expr LESS expr .)
    GREATEREQ       reduce using rule 67 (expr -> expr LESS expr .)
    LESSEQ          reduce using rule 67 (expr -> expr LESS expr .)
    NOTEQ           reduce using rule 67 (expr -> expr LESS expr .)
    EQEQ            reduce using rule 67 (expr -> expr LESS expr .)
    ID              reduce using rule 67 (expr -> expr LESS expr .)
    ?               reduce using rule 67 (expr -> expr LESS expr .)
    LET             reduce using rule 67 (expr -> expr LESS expr .)
    PRINT           reduce using rule 67 (expr -> expr LESS expr .)
    RAW_INPUT       reduce using rule 67 (expr -> expr LESS expr .)
    {               reduce using rule 67 (expr -> expr LESS expr .)
    NIL             reduce using rule 67 (expr -> expr LESS expr .)
    FALSE           reduce using rule 67 (expr -> expr LESS expr .)
    TRUE            reduce using rule 67 (expr -> expr LESS expr .)
    STRING          reduce using rule 67 (expr -> expr LESS expr .)
    FLOAT           reduce using rule 67 (expr -> expr LESS expr .)
    INT             reduce using rule 67 (expr -> expr LESS expr .)
    (               reduce using rule 67 (expr -> expr LESS expr .)
    !               reduce using rule 67 (expr -> expr LESS expr .)
    ~               reduce using rule 67 (expr -> expr LESS expr .)
    TYPEOF          reduce using rule 67 (expr -> expr LESS expr .)
    LAMBDA          reduce using rule 67 (expr -> expr LESS expr .)
    DEC             reduce using rule 67 (expr -> expr LESS expr .)
    INC             reduce using rule 67 (expr -> expr LESS expr .)
    CLASS           reduce using rule 67 (expr -> expr LESS expr .)
    STRUCT          reduce using rule 67 (expr -> expr LESS expr .)
    IF              reduce using rule 67 (expr -> expr LESS expr .)
    FOR             reduce using rule 67 (expr -> expr LESS expr .)
    WHILE           reduce using rule 67 (expr -> expr LESS expr .)
    RETURN          reduce using rule 67 (expr -> expr LESS expr .)
    FN              reduce using rule 67 (expr -> expr LESS expr .)
    IMPORT          reduce using rule 67 (expr -> expr LESS expr .)
    [               reduce using rule 67 (expr -> expr LESS expr .)
    $end            reduce using rule 67 (expr -> expr LESS expr .)
    }               reduce using rule 67 (expr -> expr LESS expr .)
    ELSE            reduce using rule 67 (expr -> expr LESS expr .)
    ]               reduce using rule 67 (expr -> expr LESS expr .)
    ,               reduce using rule 67 (expr -> expr LESS expr .)
    )               reduce using rule 67 (expr -> expr LESS expr .)
    TO              reduce using rule 67 (expr -> expr LESS expr .)
    :               reduce using rule 67 (expr -> expr LESS expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    SHR             shift and go to state 63
    SHL             shift and go to state 64


state 140

    (68) expr -> expr OR expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 68 (expr -> expr OR expr .)
    PERSENT         reduce using rule 68 (expr -> expr OR expr .)
    DIV             reduce using rule 68 (expr -> expr OR expr .)
    MUL             reduce using rule 68 (expr -> expr OR expr .)
    SUB             reduce using rule 68 (expr -> expr OR expr .)
    ADD             reduce using rule 68 (expr -> expr OR expr .)
    OR              reduce using rule 68 (expr -> expr OR expr .)
    ID              reduce using rule 68 (expr -> expr OR expr .)
    ?               reduce using rule 68 (expr -> expr OR expr .)
    LET             reduce using rule 68 (expr -> expr OR expr .)
    PRINT           reduce using rule 68 (expr -> expr OR expr .)
    RAW_INPUT       reduce using rule 68 (expr -> expr OR expr .)
    {               reduce using rule 68 (expr -> expr OR expr .)
    NIL             reduce using rule 68 (expr -> expr OR expr .)
    FALSE           reduce using rule 68 (expr -> expr OR expr .)
    TRUE            reduce using rule 68 (expr -> expr OR expr .)
    STRING          reduce using rule 68 (expr -> expr OR expr .)
    FLOAT           reduce using rule 68 (expr -> expr OR expr .)
    INT             reduce using rule 68 (expr -> expr OR expr .)
    (               reduce using rule 68 (expr -> expr OR expr .)
    !               reduce using rule 68 (expr -> expr OR expr .)
    ~               reduce using rule 68 (expr -> expr OR expr .)
    TYPEOF          reduce using rule 68 (expr -> expr OR expr .)
    LAMBDA          reduce using rule 68 (expr -> expr OR expr .)
    DEC             reduce using rule 68 (expr -> expr OR expr .)
    INC             reduce using rule 68 (expr -> expr OR expr .)
    CLASS           reduce using rule 68 (expr -> expr OR expr .)
    STRUCT          reduce using rule 68 (expr -> expr OR expr .)
    IF              reduce using rule 68 (expr -> expr OR expr .)
    FOR             reduce using rule 68 (expr -> expr OR expr .)
    WHILE           reduce using rule 68 (expr -> expr OR expr .)
    RETURN          reduce using rule 68 (expr -> expr OR expr .)
    FN              reduce using rule 68 (expr -> expr OR expr .)
    IMPORT          reduce using rule 68 (expr -> expr OR expr .)
    [               reduce using rule 68 (expr -> expr OR expr .)
    $end            reduce using rule 68 (expr -> expr OR expr .)
    }               reduce using rule 68 (expr -> expr OR expr .)
    ELSE            reduce using rule 68 (expr -> expr OR expr .)
    ]               reduce using rule 68 (expr -> expr OR expr .)
    ,               reduce using rule 68 (expr -> expr OR expr .)
    )               reduce using rule 68 (expr -> expr OR expr .)
    TO              reduce using rule 68 (expr -> expr OR expr .)
    :               reduce using rule 68 (expr -> expr OR expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72


state 141

    (69) expr -> expr AND expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 69 (expr -> expr AND expr .)
    PERSENT         reduce using rule 69 (expr -> expr AND expr .)
    DIV             reduce using rule 69 (expr -> expr AND expr .)
    MUL             reduce using rule 69 (expr -> expr AND expr .)
    SUB             reduce using rule 69 (expr -> expr AND expr .)
    ADD             reduce using rule 69 (expr -> expr AND expr .)
    OR              reduce using rule 69 (expr -> expr AND expr .)
    AND             reduce using rule 69 (expr -> expr AND expr .)
    ID              reduce using rule 69 (expr -> expr AND expr .)
    ?               reduce using rule 69 (expr -> expr AND expr .)
    LET             reduce using rule 69 (expr -> expr AND expr .)
    PRINT           reduce using rule 69 (expr -> expr AND expr .)
    RAW_INPUT       reduce using rule 69 (expr -> expr AND expr .)
    {               reduce using rule 69 (expr -> expr AND expr .)
    NIL             reduce using rule 69 (expr -> expr AND expr .)
    FALSE           reduce using rule 69 (expr -> expr AND expr .)
    TRUE            reduce using rule 69 (expr -> expr AND expr .)
    STRING          reduce using rule 69 (expr -> expr AND expr .)
    FLOAT           reduce using rule 69 (expr -> expr AND expr .)
    INT             reduce using rule 69 (expr -> expr AND expr .)
    (               reduce using rule 69 (expr -> expr AND expr .)
    !               reduce using rule 69 (expr -> expr AND expr .)
    ~               reduce using rule 69 (expr -> expr AND expr .)
    TYPEOF          reduce using rule 69 (expr -> expr AND expr .)
    LAMBDA          reduce using rule 69 (expr -> expr AND expr .)
    DEC             reduce using rule 69 (expr -> expr AND expr .)
    INC             reduce using rule 69 (expr -> expr AND expr .)
    CLASS           reduce using rule 69 (expr -> expr AND expr .)
    STRUCT          reduce using rule 69 (expr -> expr AND expr .)
    IF              reduce using rule 69 (expr -> expr AND expr .)
    FOR             reduce using rule 69 (expr -> expr AND expr .)
    WHILE           reduce using rule 69 (expr -> expr AND expr .)
    RETURN          reduce using rule 69 (expr -> expr AND expr .)
    FN              reduce using rule 69 (expr -> expr AND expr .)
    IMPORT          reduce using rule 69 (expr -> expr AND expr .)
    [               reduce using rule 69 (expr -> expr AND expr .)
    $end            reduce using rule 69 (expr -> expr AND expr .)
    }               reduce using rule 69 (expr -> expr AND expr .)
    ELSE            reduce using rule 69 (expr -> expr AND expr .)
    ]               reduce using rule 69 (expr -> expr AND expr .)
    ,               reduce using rule 69 (expr -> expr AND expr .)
    )               reduce using rule 69 (expr -> expr AND expr .)
    TO              reduce using rule 69 (expr -> expr AND expr .)
    :               reduce using rule 69 (expr -> expr AND expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72


state 142

    (70) expr -> expr GREATEREQ expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    PERSENT         reduce using rule 70 (expr -> expr GREATEREQ expr .)
    DIV             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    MUL             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    SUB             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ADD             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    |               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ^               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    &               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    GREATER         reduce using rule 70 (expr -> expr GREATEREQ expr .)
    LESS            reduce using rule 70 (expr -> expr GREATEREQ expr .)
    OR              reduce using rule 70 (expr -> expr GREATEREQ expr .)
    AND             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    GREATEREQ       reduce using rule 70 (expr -> expr GREATEREQ expr .)
    LESSEQ          reduce using rule 70 (expr -> expr GREATEREQ expr .)
    NOTEQ           reduce using rule 70 (expr -> expr GREATEREQ expr .)
    EQEQ            reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ID              reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ?               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    LET             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    PRINT           reduce using rule 70 (expr -> expr GREATEREQ expr .)
    RAW_INPUT       reduce using rule 70 (expr -> expr GREATEREQ expr .)
    {               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    NIL             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    FALSE           reduce using rule 70 (expr -> expr GREATEREQ expr .)
    TRUE            reduce using rule 70 (expr -> expr GREATEREQ expr .)
    STRING          reduce using rule 70 (expr -> expr GREATEREQ expr .)
    FLOAT           reduce using rule 70 (expr -> expr GREATEREQ expr .)
    INT             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    (               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    !               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ~               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    TYPEOF          reduce using rule 70 (expr -> expr GREATEREQ expr .)
    LAMBDA          reduce using rule 70 (expr -> expr GREATEREQ expr .)
    DEC             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    INC             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    CLASS           reduce using rule 70 (expr -> expr GREATEREQ expr .)
    STRUCT          reduce using rule 70 (expr -> expr GREATEREQ expr .)
    IF              reduce using rule 70 (expr -> expr GREATEREQ expr .)
    FOR             reduce using rule 70 (expr -> expr GREATEREQ expr .)
    WHILE           reduce using rule 70 (expr -> expr GREATEREQ expr .)
    RETURN          reduce using rule 70 (expr -> expr GREATEREQ expr .)
    FN              reduce using rule 70 (expr -> expr GREATEREQ expr .)
    IMPORT          reduce using rule 70 (expr -> expr GREATEREQ expr .)
    [               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    $end            reduce using rule 70 (expr -> expr GREATEREQ expr .)
    }               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ELSE            reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ]               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    ,               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    )               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    TO              reduce using rule 70 (expr -> expr GREATEREQ expr .)
    :               reduce using rule 70 (expr -> expr GREATEREQ expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    SHR             shift and go to state 63
    SHL             shift and go to state 64


state 143

    (71) expr -> expr LESSEQ expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 71 (expr -> expr LESSEQ expr .)
    PERSENT         reduce using rule 71 (expr -> expr LESSEQ expr .)
    DIV             reduce using rule 71 (expr -> expr LESSEQ expr .)
    MUL             reduce using rule 71 (expr -> expr LESSEQ expr .)
    SUB             reduce using rule 71 (expr -> expr LESSEQ expr .)
    ADD             reduce using rule 71 (expr -> expr LESSEQ expr .)
    |               reduce using rule 71 (expr -> expr LESSEQ expr .)
    ^               reduce using rule 71 (expr -> expr LESSEQ expr .)
    &               reduce using rule 71 (expr -> expr LESSEQ expr .)
    GREATER         reduce using rule 71 (expr -> expr LESSEQ expr .)
    LESS            reduce using rule 71 (expr -> expr LESSEQ expr .)
    OR              reduce using rule 71 (expr -> expr LESSEQ expr .)
    AND             reduce using rule 71 (expr -> expr LESSEQ expr .)
    GREATEREQ       reduce using rule 71 (expr -> expr LESSEQ expr .)
    LESSEQ          reduce using rule 71 (expr -> expr LESSEQ expr .)
    NOTEQ           reduce using rule 71 (expr -> expr LESSEQ expr .)
    EQEQ            reduce using rule 71 (expr -> expr LESSEQ expr .)
    ID              reduce using rule 71 (expr -> expr LESSEQ expr .)
    ?               reduce using rule 71 (expr -> expr LESSEQ expr .)
    LET             reduce using rule 71 (expr -> expr LESSEQ expr .)
    PRINT           reduce using rule 71 (expr -> expr LESSEQ expr .)
    RAW_INPUT       reduce using rule 71 (expr -> expr LESSEQ expr .)
    {               reduce using rule 71 (expr -> expr LESSEQ expr .)
    NIL             reduce using rule 71 (expr -> expr LESSEQ expr .)
    FALSE           reduce using rule 71 (expr -> expr LESSEQ expr .)
    TRUE            reduce using rule 71 (expr -> expr LESSEQ expr .)
    STRING          reduce using rule 71 (expr -> expr LESSEQ expr .)
    FLOAT           reduce using rule 71 (expr -> expr LESSEQ expr .)
    INT             reduce using rule 71 (expr -> expr LESSEQ expr .)
    (               reduce using rule 71 (expr -> expr LESSEQ expr .)
    !               reduce using rule 71 (expr -> expr LESSEQ expr .)
    ~               reduce using rule 71 (expr -> expr LESSEQ expr .)
    TYPEOF          reduce using rule 71 (expr -> expr LESSEQ expr .)
    LAMBDA          reduce using rule 71 (expr -> expr LESSEQ expr .)
    DEC             reduce using rule 71 (expr -> expr LESSEQ expr .)
    INC             reduce using rule 71 (expr -> expr LESSEQ expr .)
    CLASS           reduce using rule 71 (expr -> expr LESSEQ expr .)
    STRUCT          reduce using rule 71 (expr -> expr LESSEQ expr .)
    IF              reduce using rule 71 (expr -> expr LESSEQ expr .)
    FOR             reduce using rule 71 (expr -> expr LESSEQ expr .)
    WHILE           reduce using rule 71 (expr -> expr LESSEQ expr .)
    RETURN          reduce using rule 71 (expr -> expr LESSEQ expr .)
    FN              reduce using rule 71 (expr -> expr LESSEQ expr .)
    IMPORT          reduce using rule 71 (expr -> expr LESSEQ expr .)
    [               reduce using rule 71 (expr -> expr LESSEQ expr .)
    $end            reduce using rule 71 (expr -> expr LESSEQ expr .)
    }               reduce using rule 71 (expr -> expr LESSEQ expr .)
    ELSE            reduce using rule 71 (expr -> expr LESSEQ expr .)
    ]               reduce using rule 71 (expr -> expr LESSEQ expr .)
    ,               reduce using rule 71 (expr -> expr LESSEQ expr .)
    )               reduce using rule 71 (expr -> expr LESSEQ expr .)
    TO              reduce using rule 71 (expr -> expr LESSEQ expr .)
    :               reduce using rule 71 (expr -> expr LESSEQ expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    SHR             shift and go to state 63
    SHL             shift and go to state 64


state 144

    (72) expr -> expr NOTEQ expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 72 (expr -> expr NOTEQ expr .)
    PERSENT         reduce using rule 72 (expr -> expr NOTEQ expr .)
    DIV             reduce using rule 72 (expr -> expr NOTEQ expr .)
    MUL             reduce using rule 72 (expr -> expr NOTEQ expr .)
    SUB             reduce using rule 72 (expr -> expr NOTEQ expr .)
    ADD             reduce using rule 72 (expr -> expr NOTEQ expr .)
    |               reduce using rule 72 (expr -> expr NOTEQ expr .)
    ^               reduce using rule 72 (expr -> expr NOTEQ expr .)
    &               reduce using rule 72 (expr -> expr NOTEQ expr .)
    OR              reduce using rule 72 (expr -> expr NOTEQ expr .)
    AND             reduce using rule 72 (expr -> expr NOTEQ expr .)
    NOTEQ           reduce using rule 72 (expr -> expr NOTEQ expr .)
    EQEQ            reduce using rule 72 (expr -> expr NOTEQ expr .)
    ID              reduce using rule 72 (expr -> expr NOTEQ expr .)
    ?               reduce using rule 72 (expr -> expr NOTEQ expr .)
    LET             reduce using rule 72 (expr -> expr NOTEQ expr .)
    PRINT           reduce using rule 72 (expr -> expr NOTEQ expr .)
    RAW_INPUT       reduce using rule 72 (expr -> expr NOTEQ expr .)
    {               reduce using rule 72 (expr -> expr NOTEQ expr .)
    NIL             reduce using rule 72 (expr -> expr NOTEQ expr .)
    FALSE           reduce using rule 72 (expr -> expr NOTEQ expr .)
    TRUE            reduce using rule 72 (expr -> expr NOTEQ expr .)
    STRING          reduce using rule 72 (expr -> expr NOTEQ expr .)
    FLOAT           reduce using rule 72 (expr -> expr NOTEQ expr .)
    INT             reduce using rule 72 (expr -> expr NOTEQ expr .)
    (               reduce using rule 72 (expr -> expr NOTEQ expr .)
    !               reduce using rule 72 (expr -> expr NOTEQ expr .)
    ~               reduce using rule 72 (expr -> expr NOTEQ expr .)
    TYPEOF          reduce using rule 72 (expr -> expr NOTEQ expr .)
    LAMBDA          reduce using rule 72 (expr -> expr NOTEQ expr .)
    DEC             reduce using rule 72 (expr -> expr NOTEQ expr .)
    INC             reduce using rule 72 (expr -> expr NOTEQ expr .)
    CLASS           reduce using rule 72 (expr -> expr NOTEQ expr .)
    STRUCT          reduce using rule 72 (expr -> expr NOTEQ expr .)
    IF              reduce using rule 72 (expr -> expr NOTEQ expr .)
    FOR             reduce using rule 72 (expr -> expr NOTEQ expr .)
    WHILE           reduce using rule 72 (expr -> expr NOTEQ expr .)
    RETURN          reduce using rule 72 (expr -> expr NOTEQ expr .)
    FN              reduce using rule 72 (expr -> expr NOTEQ expr .)
    IMPORT          reduce using rule 72 (expr -> expr NOTEQ expr .)
    [               reduce using rule 72 (expr -> expr NOTEQ expr .)
    $end            reduce using rule 72 (expr -> expr NOTEQ expr .)
    }               reduce using rule 72 (expr -> expr NOTEQ expr .)
    ELSE            reduce using rule 72 (expr -> expr NOTEQ expr .)
    ]               reduce using rule 72 (expr -> expr NOTEQ expr .)
    ,               reduce using rule 72 (expr -> expr NOTEQ expr .)
    )               reduce using rule 72 (expr -> expr NOTEQ expr .)
    TO              reduce using rule 72 (expr -> expr NOTEQ expr .)
    :               reduce using rule 72 (expr -> expr NOTEQ expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70


state 145

    (73) expr -> expr EQEQ expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 73 (expr -> expr EQEQ expr .)
    PERSENT         reduce using rule 73 (expr -> expr EQEQ expr .)
    DIV             reduce using rule 73 (expr -> expr EQEQ expr .)
    MUL             reduce using rule 73 (expr -> expr EQEQ expr .)
    SUB             reduce using rule 73 (expr -> expr EQEQ expr .)
    ADD             reduce using rule 73 (expr -> expr EQEQ expr .)
    |               reduce using rule 73 (expr -> expr EQEQ expr .)
    ^               reduce using rule 73 (expr -> expr EQEQ expr .)
    &               reduce using rule 73 (expr -> expr EQEQ expr .)
    OR              reduce using rule 73 (expr -> expr EQEQ expr .)
    AND             reduce using rule 73 (expr -> expr EQEQ expr .)
    NOTEQ           reduce using rule 73 (expr -> expr EQEQ expr .)
    EQEQ            reduce using rule 73 (expr -> expr EQEQ expr .)
    ID              reduce using rule 73 (expr -> expr EQEQ expr .)
    ?               reduce using rule 73 (expr -> expr EQEQ expr .)
    LET             reduce using rule 73 (expr -> expr EQEQ expr .)
    PRINT           reduce using rule 73 (expr -> expr EQEQ expr .)
    RAW_INPUT       reduce using rule 73 (expr -> expr EQEQ expr .)
    {               reduce using rule 73 (expr -> expr EQEQ expr .)
    NIL             reduce using rule 73 (expr -> expr EQEQ expr .)
    FALSE           reduce using rule 73 (expr -> expr EQEQ expr .)
    TRUE            reduce using rule 73 (expr -> expr EQEQ expr .)
    STRING          reduce using rule 73 (expr -> expr EQEQ expr .)
    FLOAT           reduce using rule 73 (expr -> expr EQEQ expr .)
    INT             reduce using rule 73 (expr -> expr EQEQ expr .)
    (               reduce using rule 73 (expr -> expr EQEQ expr .)
    !               reduce using rule 73 (expr -> expr EQEQ expr .)
    ~               reduce using rule 73 (expr -> expr EQEQ expr .)
    TYPEOF          reduce using rule 73 (expr -> expr EQEQ expr .)
    LAMBDA          reduce using rule 73 (expr -> expr EQEQ expr .)
    DEC             reduce using rule 73 (expr -> expr EQEQ expr .)
    INC             reduce using rule 73 (expr -> expr EQEQ expr .)
    CLASS           reduce using rule 73 (expr -> expr EQEQ expr .)
    STRUCT          reduce using rule 73 (expr -> expr EQEQ expr .)
    IF              reduce using rule 73 (expr -> expr EQEQ expr .)
    FOR             reduce using rule 73 (expr -> expr EQEQ expr .)
    WHILE           reduce using rule 73 (expr -> expr EQEQ expr .)
    RETURN          reduce using rule 73 (expr -> expr EQEQ expr .)
    FN              reduce using rule 73 (expr -> expr EQEQ expr .)
    IMPORT          reduce using rule 73 (expr -> expr EQEQ expr .)
    [               reduce using rule 73 (expr -> expr EQEQ expr .)
    $end            reduce using rule 73 (expr -> expr EQEQ expr .)
    }               reduce using rule 73 (expr -> expr EQEQ expr .)
    ELSE            reduce using rule 73 (expr -> expr EQEQ expr .)
    ]               reduce using rule 73 (expr -> expr EQEQ expr .)
    ,               reduce using rule 73 (expr -> expr EQEQ expr .)
    )               reduce using rule 73 (expr -> expr EQEQ expr .)
    TO              reduce using rule 73 (expr -> expr EQEQ expr .)
    :               reduce using rule 73 (expr -> expr EQEQ expr .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70


state 146

    (74) expr -> expr ID ( . args )
    (117) args -> . empty
    (118) args -> . arg
    (119) args -> . args , arg
    (110) empty -> .
    (120) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 176
    args                           shift and go to state 195
    empty                          shift and go to state 174
    arg                            shift and go to state 175
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 147

    (77) expr -> expr ? expr . : expr
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    :               shift and go to state 196
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 148

    (7) statement -> LET var : . var_type SEP
    (27) var_type -> . DICT_TYPE
    (28) var_type -> . LIST_TYPE
    (29) var_type -> . BOOL_TYPE
    (30) var_type -> . STRING_TYPE
    (31) var_type -> . FLOAT_TYPE
    (32) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 198
    LIST_TYPE       shift and go to state 199
    BOOL_TYPE       shift and go to state 200
    STRING_TYPE     shift and go to state 201
    FLOAT_TYPE      shift and go to state 202
    INT_TYPE        shift and go to state 203

    var_type                       shift and go to state 197

state 149

    (84) var_define -> LET var ASSIGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 204
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 150

    (108) var -> var [ . expr ]
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    var                            shift and go to state 92
    expr                           shift and go to state 205
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 151

    (83) var_define -> LET getter ASSIGN . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    getter                         shift and go to state 20
    expr                           shift and go to state 206
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 152

    (39) expr -> var [ expr . ]
    (108) var -> var [ expr . ]
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    ]               shift and go to state 207
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 153

    (88) var_assign -> var SHRASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 88 (var_assign -> var SHRASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 154

    (89) var_assign -> var SHLASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 89 (var_assign -> var SHLASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 155

    (90) var_assign -> var XORASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 90 (var_assign -> var XORASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 156

    (91) var_assign -> var ORASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 91 (var_assign -> var ORASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 157

    (92) var_assign -> var ANDASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 92 (var_assign -> var ANDASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 158

    (93) var_assign -> var MODULOASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 93 (var_assign -> var MODULOASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 159

    (94) var_assign -> var SLASHASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 94 (var_assign -> var SLASHASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 160

    (95) var_assign -> var STARASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 95 (var_assign -> var STARASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 161

    (96) var_assign -> var MINUSASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 96 (var_assign -> var MINUSASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 162

    (97) var_assign -> var PLUSASGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 97 (var_assign -> var PLUSASGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 163

    (98) var_assign -> var ASSIGN RAW_INPUT .
    SEP             reduce using rule 98 (var_assign -> var ASSIGN RAW_INPUT .)


state 164

    (99) var_assign -> var ASSIGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 99 (var_assign -> var ASSIGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 165

    (126) getter -> getter . ID .
    .               reduce using rule 126 (getter -> getter . ID .)
    SEP             reduce using rule 126 (getter -> getter . ID .)
    PERSENT         reduce using rule 126 (getter -> getter . ID .)
    DIV             reduce using rule 126 (getter -> getter . ID .)
    MUL             reduce using rule 126 (getter -> getter . ID .)
    SUB             reduce using rule 126 (getter -> getter . ID .)
    ADD             reduce using rule 126 (getter -> getter . ID .)
    %               reduce using rule 126 (getter -> getter . ID .)
    /               reduce using rule 126 (getter -> getter . ID .)
    *               reduce using rule 126 (getter -> getter . ID .)
    -               reduce using rule 126 (getter -> getter . ID .)
    +               reduce using rule 126 (getter -> getter . ID .)
    |               reduce using rule 126 (getter -> getter . ID .)
    ^               reduce using rule 126 (getter -> getter . ID .)
    &               reduce using rule 126 (getter -> getter . ID .)
    SHR             reduce using rule 126 (getter -> getter . ID .)
    SHL             reduce using rule 126 (getter -> getter . ID .)
    GREATER         reduce using rule 126 (getter -> getter . ID .)
    LESS            reduce using rule 126 (getter -> getter . ID .)
    OR              reduce using rule 126 (getter -> getter . ID .)
    AND             reduce using rule 126 (getter -> getter . ID .)
    GREATEREQ       reduce using rule 126 (getter -> getter . ID .)
    LESSEQ          reduce using rule 126 (getter -> getter . ID .)
    NOTEQ           reduce using rule 126 (getter -> getter . ID .)
    EQEQ            reduce using rule 126 (getter -> getter . ID .)
    ID              reduce using rule 126 (getter -> getter . ID .)
    ?               reduce using rule 126 (getter -> getter . ID .)
    ASSIGN          reduce using rule 126 (getter -> getter . ID .)
    LET             reduce using rule 126 (getter -> getter . ID .)
    PRINT           reduce using rule 126 (getter -> getter . ID .)
    RAW_INPUT       reduce using rule 126 (getter -> getter . ID .)
    {               reduce using rule 126 (getter -> getter . ID .)
    NIL             reduce using rule 126 (getter -> getter . ID .)
    FALSE           reduce using rule 126 (getter -> getter . ID .)
    TRUE            reduce using rule 126 (getter -> getter . ID .)
    STRING          reduce using rule 126 (getter -> getter . ID .)
    FLOAT           reduce using rule 126 (getter -> getter . ID .)
    INT             reduce using rule 126 (getter -> getter . ID .)
    (               reduce using rule 126 (getter -> getter . ID .)
    !               reduce using rule 126 (getter -> getter . ID .)
    ~               reduce using rule 126 (getter -> getter . ID .)
    TYPEOF          reduce using rule 126 (getter -> getter . ID .)
    LAMBDA          reduce using rule 126 (getter -> getter . ID .)
    DEC             reduce using rule 126 (getter -> getter . ID .)
    INC             reduce using rule 126 (getter -> getter . ID .)
    CLASS           reduce using rule 126 (getter -> getter . ID .)
    STRUCT          reduce using rule 126 (getter -> getter . ID .)
    IF              reduce using rule 126 (getter -> getter . ID .)
    FOR             reduce using rule 126 (getter -> getter . ID .)
    WHILE           reduce using rule 126 (getter -> getter . ID .)
    RETURN          reduce using rule 126 (getter -> getter . ID .)
    FN              reduce using rule 126 (getter -> getter . ID .)
    IMPORT          reduce using rule 126 (getter -> getter . ID .)
    [               reduce using rule 126 (getter -> getter . ID .)
    $end            reduce using rule 126 (getter -> getter . ID .)
    }               reduce using rule 126 (getter -> getter . ID .)
    ELSE            reduce using rule 126 (getter -> getter . ID .)
    ]               reduce using rule 126 (getter -> getter . ID .)
    ,               reduce using rule 126 (getter -> getter . ID .)
    )               reduce using rule 126 (getter -> getter . ID .)
    TO              reduce using rule 126 (getter -> getter . ID .)
    :               reduce using rule 126 (getter -> getter . ID .)


state 166

    (36) expr -> { member_list } .
    SEP             reduce using rule 36 (expr -> { member_list } .)
    PERSENT         reduce using rule 36 (expr -> { member_list } .)
    DIV             reduce using rule 36 (expr -> { member_list } .)
    MUL             reduce using rule 36 (expr -> { member_list } .)
    SUB             reduce using rule 36 (expr -> { member_list } .)
    ADD             reduce using rule 36 (expr -> { member_list } .)
    %               reduce using rule 36 (expr -> { member_list } .)
    /               reduce using rule 36 (expr -> { member_list } .)
    *               reduce using rule 36 (expr -> { member_list } .)
    -               reduce using rule 36 (expr -> { member_list } .)
    +               reduce using rule 36 (expr -> { member_list } .)
    |               reduce using rule 36 (expr -> { member_list } .)
    ^               reduce using rule 36 (expr -> { member_list } .)
    &               reduce using rule 36 (expr -> { member_list } .)
    SHR             reduce using rule 36 (expr -> { member_list } .)
    SHL             reduce using rule 36 (expr -> { member_list } .)
    GREATER         reduce using rule 36 (expr -> { member_list } .)
    LESS            reduce using rule 36 (expr -> { member_list } .)
    OR              reduce using rule 36 (expr -> { member_list } .)
    AND             reduce using rule 36 (expr -> { member_list } .)
    GREATEREQ       reduce using rule 36 (expr -> { member_list } .)
    LESSEQ          reduce using rule 36 (expr -> { member_list } .)
    NOTEQ           reduce using rule 36 (expr -> { member_list } .)
    EQEQ            reduce using rule 36 (expr -> { member_list } .)
    ID              reduce using rule 36 (expr -> { member_list } .)
    ?               reduce using rule 36 (expr -> { member_list } .)
    LET             reduce using rule 36 (expr -> { member_list } .)
    PRINT           reduce using rule 36 (expr -> { member_list } .)
    RAW_INPUT       reduce using rule 36 (expr -> { member_list } .)
    {               reduce using rule 36 (expr -> { member_list } .)
    NIL             reduce using rule 36 (expr -> { member_list } .)
    FALSE           reduce using rule 36 (expr -> { member_list } .)
    TRUE            reduce using rule 36 (expr -> { member_list } .)
    STRING          reduce using rule 36 (expr -> { member_list } .)
    FLOAT           reduce using rule 36 (expr -> { member_list } .)
    INT             reduce using rule 36 (expr -> { member_list } .)
    (               reduce using rule 36 (expr -> { member_list } .)
    !               reduce using rule 36 (expr -> { member_list } .)
    ~               reduce using rule 36 (expr -> { member_list } .)
    TYPEOF          reduce using rule 36 (expr -> { member_list } .)
    LAMBDA          reduce using rule 36 (expr -> { member_list } .)
    DEC             reduce using rule 36 (expr -> { member_list } .)
    INC             reduce using rule 36 (expr -> { member_list } .)
    CLASS           reduce using rule 36 (expr -> { member_list } .)
    STRUCT          reduce using rule 36 (expr -> { member_list } .)
    IF              reduce using rule 36 (expr -> { member_list } .)
    FOR             reduce using rule 36 (expr -> { member_list } .)
    WHILE           reduce using rule 36 (expr -> { member_list } .)
    RETURN          reduce using rule 36 (expr -> { member_list } .)
    FN              reduce using rule 36 (expr -> { member_list } .)
    IMPORT          reduce using rule 36 (expr -> { member_list } .)
    [               reduce using rule 36 (expr -> { member_list } .)
    $end            reduce using rule 36 (expr -> { member_list } .)
    }               reduce using rule 36 (expr -> { member_list } .)
    ELSE            reduce using rule 36 (expr -> { member_list } .)
    ]               reduce using rule 36 (expr -> { member_list } .)
    ,               reduce using rule 36 (expr -> { member_list } .)
    )               reduce using rule 36 (expr -> { member_list } .)
    TO              reduce using rule 36 (expr -> { member_list } .)
    :               reduce using rule 36 (expr -> { member_list } .)


state 167

    (121) member_list -> member_list , . member
    (124) member -> . STRING : expr
    STRING          shift and go to state 98

    member                         shift and go to state 208

state 168

    (124) member -> STRING : . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 209
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 169

    (104) list_val -> [ exprs ] .
    SEP             reduce using rule 104 (list_val -> [ exprs ] .)
    PERSENT         reduce using rule 104 (list_val -> [ exprs ] .)
    DIV             reduce using rule 104 (list_val -> [ exprs ] .)
    MUL             reduce using rule 104 (list_val -> [ exprs ] .)
    SUB             reduce using rule 104 (list_val -> [ exprs ] .)
    ADD             reduce using rule 104 (list_val -> [ exprs ] .)
    %               reduce using rule 104 (list_val -> [ exprs ] .)
    /               reduce using rule 104 (list_val -> [ exprs ] .)
    *               reduce using rule 104 (list_val -> [ exprs ] .)
    -               reduce using rule 104 (list_val -> [ exprs ] .)
    +               reduce using rule 104 (list_val -> [ exprs ] .)
    |               reduce using rule 104 (list_val -> [ exprs ] .)
    ^               reduce using rule 104 (list_val -> [ exprs ] .)
    &               reduce using rule 104 (list_val -> [ exprs ] .)
    SHR             reduce using rule 104 (list_val -> [ exprs ] .)
    SHL             reduce using rule 104 (list_val -> [ exprs ] .)
    GREATER         reduce using rule 104 (list_val -> [ exprs ] .)
    LESS            reduce using rule 104 (list_val -> [ exprs ] .)
    OR              reduce using rule 104 (list_val -> [ exprs ] .)
    AND             reduce using rule 104 (list_val -> [ exprs ] .)
    GREATEREQ       reduce using rule 104 (list_val -> [ exprs ] .)
    LESSEQ          reduce using rule 104 (list_val -> [ exprs ] .)
    NOTEQ           reduce using rule 104 (list_val -> [ exprs ] .)
    EQEQ            reduce using rule 104 (list_val -> [ exprs ] .)
    ID              reduce using rule 104 (list_val -> [ exprs ] .)
    ?               reduce using rule 104 (list_val -> [ exprs ] .)
    LET             reduce using rule 104 (list_val -> [ exprs ] .)
    PRINT           reduce using rule 104 (list_val -> [ exprs ] .)
    RAW_INPUT       reduce using rule 104 (list_val -> [ exprs ] .)
    {               reduce using rule 104 (list_val -> [ exprs ] .)
    NIL             reduce using rule 104 (list_val -> [ exprs ] .)
    FALSE           reduce using rule 104 (list_val -> [ exprs ] .)
    TRUE            reduce using rule 104 (list_val -> [ exprs ] .)
    STRING          reduce using rule 104 (list_val -> [ exprs ] .)
    FLOAT           reduce using rule 104 (list_val -> [ exprs ] .)
    INT             reduce using rule 104 (list_val -> [ exprs ] .)
    (               reduce using rule 104 (list_val -> [ exprs ] .)
    !               reduce using rule 104 (list_val -> [ exprs ] .)
    ~               reduce using rule 104 (list_val -> [ exprs ] .)
    TYPEOF          reduce using rule 104 (list_val -> [ exprs ] .)
    LAMBDA          reduce using rule 104 (list_val -> [ exprs ] .)
    DEC             reduce using rule 104 (list_val -> [ exprs ] .)
    INC             reduce using rule 104 (list_val -> [ exprs ] .)
    CLASS           reduce using rule 104 (list_val -> [ exprs ] .)
    STRUCT          reduce using rule 104 (list_val -> [ exprs ] .)
    IF              reduce using rule 104 (list_val -> [ exprs ] .)
    FOR             reduce using rule 104 (list_val -> [ exprs ] .)
    WHILE           reduce using rule 104 (list_val -> [ exprs ] .)
    RETURN          reduce using rule 104 (list_val -> [ exprs ] .)
    FN              reduce using rule 104 (list_val -> [ exprs ] .)
    IMPORT          reduce using rule 104 (list_val -> [ exprs ] .)
    [               reduce using rule 104 (list_val -> [ exprs ] .)
    $end            reduce using rule 104 (list_val -> [ exprs ] .)
    }               reduce using rule 104 (list_val -> [ exprs ] .)
    ELSE            reduce using rule 104 (list_val -> [ exprs ] .)
    ]               reduce using rule 104 (list_val -> [ exprs ] .)
    ,               reduce using rule 104 (list_val -> [ exprs ] .)
    )               reduce using rule 104 (list_val -> [ exprs ] .)
    TO              reduce using rule 104 (list_val -> [ exprs ] .)
    :               reduce using rule 104 (list_val -> [ exprs ] .)


state 170

    (105) exprs -> exprs , . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 210
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 171

    (46) expr -> ( expr ) .
    SEP             reduce using rule 46 (expr -> ( expr ) .)
    PERSENT         reduce using rule 46 (expr -> ( expr ) .)
    DIV             reduce using rule 46 (expr -> ( expr ) .)
    MUL             reduce using rule 46 (expr -> ( expr ) .)
    SUB             reduce using rule 46 (expr -> ( expr ) .)
    ADD             reduce using rule 46 (expr -> ( expr ) .)
    %               reduce using rule 46 (expr -> ( expr ) .)
    /               reduce using rule 46 (expr -> ( expr ) .)
    *               reduce using rule 46 (expr -> ( expr ) .)
    -               reduce using rule 46 (expr -> ( expr ) .)
    +               reduce using rule 46 (expr -> ( expr ) .)
    |               reduce using rule 46 (expr -> ( expr ) .)
    ^               reduce using rule 46 (expr -> ( expr ) .)
    &               reduce using rule 46 (expr -> ( expr ) .)
    SHR             reduce using rule 46 (expr -> ( expr ) .)
    SHL             reduce using rule 46 (expr -> ( expr ) .)
    GREATER         reduce using rule 46 (expr -> ( expr ) .)
    LESS            reduce using rule 46 (expr -> ( expr ) .)
    OR              reduce using rule 46 (expr -> ( expr ) .)
    AND             reduce using rule 46 (expr -> ( expr ) .)
    GREATEREQ       reduce using rule 46 (expr -> ( expr ) .)
    LESSEQ          reduce using rule 46 (expr -> ( expr ) .)
    NOTEQ           reduce using rule 46 (expr -> ( expr ) .)
    EQEQ            reduce using rule 46 (expr -> ( expr ) .)
    ID              reduce using rule 46 (expr -> ( expr ) .)
    ?               reduce using rule 46 (expr -> ( expr ) .)
    LET             reduce using rule 46 (expr -> ( expr ) .)
    PRINT           reduce using rule 46 (expr -> ( expr ) .)
    RAW_INPUT       reduce using rule 46 (expr -> ( expr ) .)
    {               reduce using rule 46 (expr -> ( expr ) .)
    NIL             reduce using rule 46 (expr -> ( expr ) .)
    FALSE           reduce using rule 46 (expr -> ( expr ) .)
    TRUE            reduce using rule 46 (expr -> ( expr ) .)
    STRING          reduce using rule 46 (expr -> ( expr ) .)
    FLOAT           reduce using rule 46 (expr -> ( expr ) .)
    INT             reduce using rule 46 (expr -> ( expr ) .)
    (               reduce using rule 46 (expr -> ( expr ) .)
    !               reduce using rule 46 (expr -> ( expr ) .)
    ~               reduce using rule 46 (expr -> ( expr ) .)
    TYPEOF          reduce using rule 46 (expr -> ( expr ) .)
    LAMBDA          reduce using rule 46 (expr -> ( expr ) .)
    DEC             reduce using rule 46 (expr -> ( expr ) .)
    INC             reduce using rule 46 (expr -> ( expr ) .)
    CLASS           reduce using rule 46 (expr -> ( expr ) .)
    STRUCT          reduce using rule 46 (expr -> ( expr ) .)
    IF              reduce using rule 46 (expr -> ( expr ) .)
    FOR             reduce using rule 46 (expr -> ( expr ) .)
    WHILE           reduce using rule 46 (expr -> ( expr ) .)
    RETURN          reduce using rule 46 (expr -> ( expr ) .)
    FN              reduce using rule 46 (expr -> ( expr ) .)
    IMPORT          reduce using rule 46 (expr -> ( expr ) .)
    [               reduce using rule 46 (expr -> ( expr ) .)
    $end            reduce using rule 46 (expr -> ( expr ) .)
    }               reduce using rule 46 (expr -> ( expr ) .)
    ELSE            reduce using rule 46 (expr -> ( expr ) .)
    ]               reduce using rule 46 (expr -> ( expr ) .)
    ,               reduce using rule 46 (expr -> ( expr ) .)
    )               reduce using rule 46 (expr -> ( expr ) .)
    TO              reduce using rule 46 (expr -> ( expr ) .)
    :               reduce using rule 46 (expr -> ( expr ) .)


state 172

    (75) expr -> ID DOUBLECOLON ID . ( args )
    (               shift and go to state 211


state 173

    (76) expr -> ID ( args . )
    (119) args -> args . , arg
    )               shift and go to state 212
    ,               shift and go to state 213


state 174

    (117) args -> empty .
    )               reduce using rule 117 (args -> empty .)
    ,               reduce using rule 117 (args -> empty .)


state 175

    (118) args -> arg .
    )               reduce using rule 118 (args -> arg .)
    ,               reduce using rule 118 (args -> arg .)


state 176

    (120) arg -> expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    )               reduce using rule 120 (arg -> expr .)
    ,               reduce using rule 120 (arg -> expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 177

    (80) expr -> ID LEFTARROW { . struct_init_exprs }
    (81) struct_init_exprs -> . struct_init_exprs , expr
    (82) struct_init_exprs -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    struct_init_exprs              shift and go to state 214
    expr                           shift and go to state 215
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 178

    (79) expr -> LAMBDA ( params . ) ARROW expr
    (115) params -> params . , param
    )               shift and go to state 216
    ,               shift and go to state 217


state 179

    (113) params -> empty .
    )               reduce using rule 113 (params -> empty .)
    ,               reduce using rule 113 (params -> empty .)


state 180

    (114) params -> param .
    )               reduce using rule 114 (params -> param .)
    ,               reduce using rule 114 (params -> param .)


state 181

    (116) param -> ID . var_type
    (27) var_type -> . DICT_TYPE
    (28) var_type -> . LIST_TYPE
    (29) var_type -> . BOOL_TYPE
    (30) var_type -> . STRING_TYPE
    (31) var_type -> . FLOAT_TYPE
    (32) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 198
    LIST_TYPE       shift and go to state 199
    BOOL_TYPE       shift and go to state 200
    STRING_TYPE     shift and go to state 201
    FLOAT_TYPE      shift and go to state 202
    INT_TYPE        shift and go to state 203

    var_type                       shift and go to state 218

state 182

    (19) class_definition -> CLASS ID { . function_definitions }
    (20) function_definitions -> . function_definitions function_definition
    (21) function_definitions -> . function_definition
    (22) function_definitions -> . empty
    (34) function_definition -> . FN ID ( params ) block
    (110) empty -> .
  ! shift/reduce conflict for FN resolved as shift
    FN              shift and go to state 46
    }               reduce using rule 110 (empty -> .)

    function_definitions           shift and go to state 219
    function_definition            shift and go to state 220
    empty                          shift and go to state 221

state 183

    (23) struct_definition -> STRUCT ID { . struct_fields } SEP
    (24) struct_fields -> . struct_fields struct_field
    (25) struct_fields -> . struct_field
    (26) struct_field -> . LET ID : var_type SEP
    LET             shift and go to state 224

    struct_fields                  shift and go to state 222
    struct_field                   shift and go to state 223

state 184

    (100) if_statement -> IF expr block .
    (101) if_statement -> IF expr block . ELSE block
  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 100 (if_statement -> IF expr block .)
    PRINT           reduce using rule 100 (if_statement -> IF expr block .)
    RAW_INPUT       reduce using rule 100 (if_statement -> IF expr block .)
    {               reduce using rule 100 (if_statement -> IF expr block .)
    NIL             reduce using rule 100 (if_statement -> IF expr block .)
    FALSE           reduce using rule 100 (if_statement -> IF expr block .)
    TRUE            reduce using rule 100 (if_statement -> IF expr block .)
    STRING          reduce using rule 100 (if_statement -> IF expr block .)
    FLOAT           reduce using rule 100 (if_statement -> IF expr block .)
    INT             reduce using rule 100 (if_statement -> IF expr block .)
    (               reduce using rule 100 (if_statement -> IF expr block .)
    !               reduce using rule 100 (if_statement -> IF expr block .)
    +               reduce using rule 100 (if_statement -> IF expr block .)
    -               reduce using rule 100 (if_statement -> IF expr block .)
    ~               reduce using rule 100 (if_statement -> IF expr block .)
    ID              reduce using rule 100 (if_statement -> IF expr block .)
    TYPEOF          reduce using rule 100 (if_statement -> IF expr block .)
    LAMBDA          reduce using rule 100 (if_statement -> IF expr block .)
    DEC             reduce using rule 100 (if_statement -> IF expr block .)
    INC             reduce using rule 100 (if_statement -> IF expr block .)
    CLASS           reduce using rule 100 (if_statement -> IF expr block .)
    STRUCT          reduce using rule 100 (if_statement -> IF expr block .)
    IF              reduce using rule 100 (if_statement -> IF expr block .)
    FOR             reduce using rule 100 (if_statement -> IF expr block .)
    WHILE           reduce using rule 100 (if_statement -> IF expr block .)
    RETURN          reduce using rule 100 (if_statement -> IF expr block .)
    FN              reduce using rule 100 (if_statement -> IF expr block .)
    IMPORT          reduce using rule 100 (if_statement -> IF expr block .)
    [               reduce using rule 100 (if_statement -> IF expr block .)
    $end            reduce using rule 100 (if_statement -> IF expr block .)
    }               reduce using rule 100 (if_statement -> IF expr block .)
    ELSE            shift and go to state 225


state 185

    (55) expr -> expr - . expr
    (59) expr -> - . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 226
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 186

    (56) expr -> expr + . expr
    (58) expr -> + . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 227
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 187

    (74) expr -> expr ID . ( args )
    (75) expr -> ID . DOUBLECOLON ID ( args )
    (76) expr -> ID . ( args )
    (80) expr -> ID . LEFTARROW { struct_init_exprs }
    (125) getter -> ID .
    (109) var -> ID .
  ! reduce/reduce conflict for SEP resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for PERSENT resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for DIV resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for MUL resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for SUB resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ADD resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for % resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for / resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for * resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for - resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for + resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for | resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ^ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for & resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for SHR resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for SHL resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for EQEQ resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 109 (var -> ID .)
  ! reduce/reduce conflict for ? resolved using rule 109 (var -> ID .)
    (               shift and go to state 228
    DOUBLECOLON     shift and go to state 107
    LEFTARROW       shift and go to state 109
    .               reduce using rule 125 (getter -> ID .)
    [               reduce using rule 109 (var -> ID .)
    SHRASGN         reduce using rule 109 (var -> ID .)
    SHLASGN         reduce using rule 109 (var -> ID .)
    XORASGN         reduce using rule 109 (var -> ID .)
    ORASGN          reduce using rule 109 (var -> ID .)
    ANDASGN         reduce using rule 109 (var -> ID .)
    MODULOASGN      reduce using rule 109 (var -> ID .)
    SLASHASGN       reduce using rule 109 (var -> ID .)
    STARASGN        reduce using rule 109 (var -> ID .)
    MINUSASGN       reduce using rule 109 (var -> ID .)
    PLUSASGN        reduce using rule 109 (var -> ID .)
    ASSIGN          reduce using rule 109 (var -> ID .)
    SEP             reduce using rule 109 (var -> ID .)
    PERSENT         reduce using rule 109 (var -> ID .)
    DIV             reduce using rule 109 (var -> ID .)
    MUL             reduce using rule 109 (var -> ID .)
    SUB             reduce using rule 109 (var -> ID .)
    ADD             reduce using rule 109 (var -> ID .)
    %               reduce using rule 109 (var -> ID .)
    /               reduce using rule 109 (var -> ID .)
    *               reduce using rule 109 (var -> ID .)
    -               reduce using rule 109 (var -> ID .)
    +               reduce using rule 109 (var -> ID .)
    |               reduce using rule 109 (var -> ID .)
    ^               reduce using rule 109 (var -> ID .)
    &               reduce using rule 109 (var -> ID .)
    SHR             reduce using rule 109 (var -> ID .)
    SHL             reduce using rule 109 (var -> ID .)
    GREATER         reduce using rule 109 (var -> ID .)
    LESS            reduce using rule 109 (var -> ID .)
    OR              reduce using rule 109 (var -> ID .)
    AND             reduce using rule 109 (var -> ID .)
    GREATEREQ       reduce using rule 109 (var -> ID .)
    LESSEQ          reduce using rule 109 (var -> ID .)
    NOTEQ           reduce using rule 109 (var -> ID .)
    EQEQ            reduce using rule 109 (var -> ID .)
    ID              reduce using rule 109 (var -> ID .)
    ?               reduce using rule 109 (var -> ID .)


state 188

    (111) block -> statement .
    ELSE            reduce using rule 111 (block -> statement .)
    LET             reduce using rule 111 (block -> statement .)
    PRINT           reduce using rule 111 (block -> statement .)
    RAW_INPUT       reduce using rule 111 (block -> statement .)
    {               reduce using rule 111 (block -> statement .)
    NIL             reduce using rule 111 (block -> statement .)
    FALSE           reduce using rule 111 (block -> statement .)
    TRUE            reduce using rule 111 (block -> statement .)
    STRING          reduce using rule 111 (block -> statement .)
    FLOAT           reduce using rule 111 (block -> statement .)
    INT             reduce using rule 111 (block -> statement .)
    (               reduce using rule 111 (block -> statement .)
    !               reduce using rule 111 (block -> statement .)
    +               reduce using rule 111 (block -> statement .)
    -               reduce using rule 111 (block -> statement .)
    ~               reduce using rule 111 (block -> statement .)
    ID              reduce using rule 111 (block -> statement .)
    TYPEOF          reduce using rule 111 (block -> statement .)
    LAMBDA          reduce using rule 111 (block -> statement .)
    DEC             reduce using rule 111 (block -> statement .)
    INC             reduce using rule 111 (block -> statement .)
    CLASS           reduce using rule 111 (block -> statement .)
    STRUCT          reduce using rule 111 (block -> statement .)
    IF              reduce using rule 111 (block -> statement .)
    FOR             reduce using rule 111 (block -> statement .)
    WHILE           reduce using rule 111 (block -> statement .)
    RETURN          reduce using rule 111 (block -> statement .)
    FN              reduce using rule 111 (block -> statement .)
    IMPORT          reduce using rule 111 (block -> statement .)
    [               reduce using rule 111 (block -> statement .)
    $end            reduce using rule 111 (block -> statement .)
    }               reduce using rule 111 (block -> statement .)


state 189

    (112) block -> { . program }
    (36) expr -> { . member_list }
    (1) program -> . empty
    (2) program -> . statements
    (121) member_list -> . member_list , member
    (122) member_list -> . member
    (123) member_list -> . empty
    (110) empty -> .
    (3) statements -> . statements statement
    (4) statements -> . statement
    (124) member -> . STRING : expr
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    }               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    STRING          shift and go to state 231
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    program                        shift and go to state 229
    member_list                    shift and go to state 95
    empty                          shift and go to state 230
    statements                     shift and go to state 3
    member                         shift and go to state 96
    statement                      shift and go to state 4
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 190

    (103) for_statement -> FOR expr TO . expr block
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 232
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 191

    (102) while_statement -> WHILE expr block .
    LET             reduce using rule 102 (while_statement -> WHILE expr block .)
    PRINT           reduce using rule 102 (while_statement -> WHILE expr block .)
    RAW_INPUT       reduce using rule 102 (while_statement -> WHILE expr block .)
    {               reduce using rule 102 (while_statement -> WHILE expr block .)
    NIL             reduce using rule 102 (while_statement -> WHILE expr block .)
    FALSE           reduce using rule 102 (while_statement -> WHILE expr block .)
    TRUE            reduce using rule 102 (while_statement -> WHILE expr block .)
    STRING          reduce using rule 102 (while_statement -> WHILE expr block .)
    FLOAT           reduce using rule 102 (while_statement -> WHILE expr block .)
    INT             reduce using rule 102 (while_statement -> WHILE expr block .)
    (               reduce using rule 102 (while_statement -> WHILE expr block .)
    !               reduce using rule 102 (while_statement -> WHILE expr block .)
    +               reduce using rule 102 (while_statement -> WHILE expr block .)
    -               reduce using rule 102 (while_statement -> WHILE expr block .)
    ~               reduce using rule 102 (while_statement -> WHILE expr block .)
    ID              reduce using rule 102 (while_statement -> WHILE expr block .)
    TYPEOF          reduce using rule 102 (while_statement -> WHILE expr block .)
    LAMBDA          reduce using rule 102 (while_statement -> WHILE expr block .)
    DEC             reduce using rule 102 (while_statement -> WHILE expr block .)
    INC             reduce using rule 102 (while_statement -> WHILE expr block .)
    CLASS           reduce using rule 102 (while_statement -> WHILE expr block .)
    STRUCT          reduce using rule 102 (while_statement -> WHILE expr block .)
    IF              reduce using rule 102 (while_statement -> WHILE expr block .)
    FOR             reduce using rule 102 (while_statement -> WHILE expr block .)
    WHILE           reduce using rule 102 (while_statement -> WHILE expr block .)
    RETURN          reduce using rule 102 (while_statement -> WHILE expr block .)
    FN              reduce using rule 102 (while_statement -> WHILE expr block .)
    IMPORT          reduce using rule 102 (while_statement -> WHILE expr block .)
    [               reduce using rule 102 (while_statement -> WHILE expr block .)
    $end            reduce using rule 102 (while_statement -> WHILE expr block .)
    }               reduce using rule 102 (while_statement -> WHILE expr block .)
    ELSE            reduce using rule 102 (while_statement -> WHILE expr block .)


state 192

    (85) return_statement -> RETURN expr SEP .
    LET             reduce using rule 85 (return_statement -> RETURN expr SEP .)
    PRINT           reduce using rule 85 (return_statement -> RETURN expr SEP .)
    RAW_INPUT       reduce using rule 85 (return_statement -> RETURN expr SEP .)
    {               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    NIL             reduce using rule 85 (return_statement -> RETURN expr SEP .)
    FALSE           reduce using rule 85 (return_statement -> RETURN expr SEP .)
    TRUE            reduce using rule 85 (return_statement -> RETURN expr SEP .)
    STRING          reduce using rule 85 (return_statement -> RETURN expr SEP .)
    FLOAT           reduce using rule 85 (return_statement -> RETURN expr SEP .)
    INT             reduce using rule 85 (return_statement -> RETURN expr SEP .)
    (               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    !               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    +               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    -               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    ~               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    ID              reduce using rule 85 (return_statement -> RETURN expr SEP .)
    TYPEOF          reduce using rule 85 (return_statement -> RETURN expr SEP .)
    LAMBDA          reduce using rule 85 (return_statement -> RETURN expr SEP .)
    DEC             reduce using rule 85 (return_statement -> RETURN expr SEP .)
    INC             reduce using rule 85 (return_statement -> RETURN expr SEP .)
    CLASS           reduce using rule 85 (return_statement -> RETURN expr SEP .)
    STRUCT          reduce using rule 85 (return_statement -> RETURN expr SEP .)
    IF              reduce using rule 85 (return_statement -> RETURN expr SEP .)
    FOR             reduce using rule 85 (return_statement -> RETURN expr SEP .)
    WHILE           reduce using rule 85 (return_statement -> RETURN expr SEP .)
    RETURN          reduce using rule 85 (return_statement -> RETURN expr SEP .)
    FN              reduce using rule 85 (return_statement -> RETURN expr SEP .)
    IMPORT          reduce using rule 85 (return_statement -> RETURN expr SEP .)
    [               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    $end            reduce using rule 85 (return_statement -> RETURN expr SEP .)
    }               reduce using rule 85 (return_statement -> RETURN expr SEP .)
    ELSE            reduce using rule 85 (return_statement -> RETURN expr SEP .)


state 193

    (34) function_definition -> FN ID ( . params ) block
    (113) params -> . empty
    (114) params -> . param
    (115) params -> . params , param
    (110) empty -> .
    (116) param -> . ID var_type
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    ID              shift and go to state 181

    params                         shift and go to state 233
    empty                          shift and go to state 179
    param                          shift and go to state 180

state 194

    (33) import_statement -> IMPORT STRING SEP .
    LET             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    PRINT           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    RAW_INPUT       reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    {               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    NIL             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FALSE           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    TRUE            reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    STRING          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FLOAT           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    INT             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    (               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    !               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    +               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    -               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    ~               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    ID              reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    TYPEOF          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    LAMBDA          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    DEC             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    INC             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    CLASS           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    STRUCT          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    IF              reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FOR             reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    WHILE           reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    RETURN          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    FN              reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    IMPORT          reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    [               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    $end            reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    }               reduce using rule 33 (import_statement -> IMPORT STRING SEP .)
    ELSE            reduce using rule 33 (import_statement -> IMPORT STRING SEP .)


state 195

    (74) expr -> expr ID ( args . )
    (119) args -> args . , arg
    )               shift and go to state 234
    ,               shift and go to state 213


state 196

    (77) expr -> expr ? expr : . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 235
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 197

    (7) statement -> LET var : var_type . SEP
    SEP             shift and go to state 236


state 198

    (27) var_type -> DICT_TYPE .
    SEP             reduce using rule 27 (var_type -> DICT_TYPE .)
    )               reduce using rule 27 (var_type -> DICT_TYPE .)
    ,               reduce using rule 27 (var_type -> DICT_TYPE .)


state 199

    (28) var_type -> LIST_TYPE .
    SEP             reduce using rule 28 (var_type -> LIST_TYPE .)
    )               reduce using rule 28 (var_type -> LIST_TYPE .)
    ,               reduce using rule 28 (var_type -> LIST_TYPE .)


state 200

    (29) var_type -> BOOL_TYPE .
    SEP             reduce using rule 29 (var_type -> BOOL_TYPE .)
    )               reduce using rule 29 (var_type -> BOOL_TYPE .)
    ,               reduce using rule 29 (var_type -> BOOL_TYPE .)


state 201

    (30) var_type -> STRING_TYPE .
    SEP             reduce using rule 30 (var_type -> STRING_TYPE .)
    )               reduce using rule 30 (var_type -> STRING_TYPE .)
    ,               reduce using rule 30 (var_type -> STRING_TYPE .)


state 202

    (31) var_type -> FLOAT_TYPE .
    SEP             reduce using rule 31 (var_type -> FLOAT_TYPE .)
    )               reduce using rule 31 (var_type -> FLOAT_TYPE .)
    ,               reduce using rule 31 (var_type -> FLOAT_TYPE .)


state 203

    (32) var_type -> INT_TYPE .
    SEP             reduce using rule 32 (var_type -> INT_TYPE .)
    )               reduce using rule 32 (var_type -> INT_TYPE .)
    ,               reduce using rule 32 (var_type -> INT_TYPE .)


state 204

    (84) var_define -> LET var ASSIGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 84 (var_define -> LET var ASSIGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 205

    (108) var -> var [ expr . ]
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    ]               shift and go to state 237
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 206

    (83) var_define -> LET getter ASSIGN expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    SEP             reduce using rule 83 (var_define -> LET getter ASSIGN expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 207

    (39) expr -> var [ expr ] .
    (108) var -> var [ expr ] .
  ! reduce/reduce conflict for [ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SEP resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for PERSENT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for DIV resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for MUL resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SUB resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ADD resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for % resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for / resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for * resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for - resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for + resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for | resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ^ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for & resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SHR resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for SHL resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for GREATER resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LESS resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for OR resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for AND resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for EQEQ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ID resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ? resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LET resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for PRINT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for RAW_INPUT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for { resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for NIL resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FALSE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for TRUE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for STRING resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FLOAT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for INT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ( resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ! resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ~ resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for TYPEOF resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for LAMBDA resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for DEC resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for INC resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for CLASS resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for STRUCT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for IF resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FOR resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for WHILE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for RETURN resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for FN resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for IMPORT resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for $end resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for } resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ELSE resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ] resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for , resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for ) resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for TO resolved using rule 39 (expr -> var [ expr ] .)
  ! reduce/reduce conflict for : resolved using rule 39 (expr -> var [ expr ] .)
    SEP             reduce using rule 39 (expr -> var [ expr ] .)
    PERSENT         reduce using rule 39 (expr -> var [ expr ] .)
    DIV             reduce using rule 39 (expr -> var [ expr ] .)
    MUL             reduce using rule 39 (expr -> var [ expr ] .)
    SUB             reduce using rule 39 (expr -> var [ expr ] .)
    ADD             reduce using rule 39 (expr -> var [ expr ] .)
    %               reduce using rule 39 (expr -> var [ expr ] .)
    /               reduce using rule 39 (expr -> var [ expr ] .)
    *               reduce using rule 39 (expr -> var [ expr ] .)
    -               reduce using rule 39 (expr -> var [ expr ] .)
    +               reduce using rule 39 (expr -> var [ expr ] .)
    |               reduce using rule 39 (expr -> var [ expr ] .)
    ^               reduce using rule 39 (expr -> var [ expr ] .)
    &               reduce using rule 39 (expr -> var [ expr ] .)
    SHR             reduce using rule 39 (expr -> var [ expr ] .)
    SHL             reduce using rule 39 (expr -> var [ expr ] .)
    GREATER         reduce using rule 39 (expr -> var [ expr ] .)
    LESS            reduce using rule 39 (expr -> var [ expr ] .)
    OR              reduce using rule 39 (expr -> var [ expr ] .)
    AND             reduce using rule 39 (expr -> var [ expr ] .)
    GREATEREQ       reduce using rule 39 (expr -> var [ expr ] .)
    LESSEQ          reduce using rule 39 (expr -> var [ expr ] .)
    NOTEQ           reduce using rule 39 (expr -> var [ expr ] .)
    EQEQ            reduce using rule 39 (expr -> var [ expr ] .)
    ID              reduce using rule 39 (expr -> var [ expr ] .)
    ?               reduce using rule 39 (expr -> var [ expr ] .)
    LET             reduce using rule 39 (expr -> var [ expr ] .)
    PRINT           reduce using rule 39 (expr -> var [ expr ] .)
    RAW_INPUT       reduce using rule 39 (expr -> var [ expr ] .)
    {               reduce using rule 39 (expr -> var [ expr ] .)
    NIL             reduce using rule 39 (expr -> var [ expr ] .)
    FALSE           reduce using rule 39 (expr -> var [ expr ] .)
    TRUE            reduce using rule 39 (expr -> var [ expr ] .)
    STRING          reduce using rule 39 (expr -> var [ expr ] .)
    FLOAT           reduce using rule 39 (expr -> var [ expr ] .)
    INT             reduce using rule 39 (expr -> var [ expr ] .)
    (               reduce using rule 39 (expr -> var [ expr ] .)
    !               reduce using rule 39 (expr -> var [ expr ] .)
    ~               reduce using rule 39 (expr -> var [ expr ] .)
    TYPEOF          reduce using rule 39 (expr -> var [ expr ] .)
    LAMBDA          reduce using rule 39 (expr -> var [ expr ] .)
    DEC             reduce using rule 39 (expr -> var [ expr ] .)
    INC             reduce using rule 39 (expr -> var [ expr ] .)
    CLASS           reduce using rule 39 (expr -> var [ expr ] .)
    STRUCT          reduce using rule 39 (expr -> var [ expr ] .)
    IF              reduce using rule 39 (expr -> var [ expr ] .)
    FOR             reduce using rule 39 (expr -> var [ expr ] .)
    WHILE           reduce using rule 39 (expr -> var [ expr ] .)
    RETURN          reduce using rule 39 (expr -> var [ expr ] .)
    FN              reduce using rule 39 (expr -> var [ expr ] .)
    IMPORT          reduce using rule 39 (expr -> var [ expr ] .)
    [               reduce using rule 39 (expr -> var [ expr ] .)
    $end            reduce using rule 39 (expr -> var [ expr ] .)
    }               reduce using rule 39 (expr -> var [ expr ] .)
    ELSE            reduce using rule 39 (expr -> var [ expr ] .)
    ]               reduce using rule 39 (expr -> var [ expr ] .)
    ,               reduce using rule 39 (expr -> var [ expr ] .)
    )               reduce using rule 39 (expr -> var [ expr ] .)
    TO              reduce using rule 39 (expr -> var [ expr ] .)
    :               reduce using rule 39 (expr -> var [ expr ] .)
    SHRASGN         reduce using rule 108 (var -> var [ expr ] .)
    SHLASGN         reduce using rule 108 (var -> var [ expr ] .)
    XORASGN         reduce using rule 108 (var -> var [ expr ] .)
    ORASGN          reduce using rule 108 (var -> var [ expr ] .)
    ANDASGN         reduce using rule 108 (var -> var [ expr ] .)
    MODULOASGN      reduce using rule 108 (var -> var [ expr ] .)
    SLASHASGN       reduce using rule 108 (var -> var [ expr ] .)
    STARASGN        reduce using rule 108 (var -> var [ expr ] .)
    MINUSASGN       reduce using rule 108 (var -> var [ expr ] .)
    PLUSASGN        reduce using rule 108 (var -> var [ expr ] .)
    ASSIGN          reduce using rule 108 (var -> var [ expr ] .)


state 208

    (121) member_list -> member_list , member .
    }               reduce using rule 121 (member_list -> member_list , member .)
    ,               reduce using rule 121 (member_list -> member_list , member .)


state 209

    (124) member -> STRING : expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    }               reduce using rule 124 (member -> STRING : expr .)
    ,               reduce using rule 124 (member -> STRING : expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 210

    (105) exprs -> exprs , expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    ]               reduce using rule 105 (exprs -> exprs , expr .)
    ,               reduce using rule 105 (exprs -> exprs , expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 211

    (75) expr -> ID DOUBLECOLON ID ( . args )
    (117) args -> . empty
    (118) args -> . arg
    (119) args -> . args , arg
    (110) empty -> .
    (120) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    args                           shift and go to state 238
    empty                          shift and go to state 174
    arg                            shift and go to state 175
    expr                           shift and go to state 176
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 212

    (76) expr -> ID ( args ) .
    SEP             reduce using rule 76 (expr -> ID ( args ) .)
    PERSENT         reduce using rule 76 (expr -> ID ( args ) .)
    DIV             reduce using rule 76 (expr -> ID ( args ) .)
    MUL             reduce using rule 76 (expr -> ID ( args ) .)
    SUB             reduce using rule 76 (expr -> ID ( args ) .)
    ADD             reduce using rule 76 (expr -> ID ( args ) .)
    %               reduce using rule 76 (expr -> ID ( args ) .)
    /               reduce using rule 76 (expr -> ID ( args ) .)
    *               reduce using rule 76 (expr -> ID ( args ) .)
    -               reduce using rule 76 (expr -> ID ( args ) .)
    +               reduce using rule 76 (expr -> ID ( args ) .)
    |               reduce using rule 76 (expr -> ID ( args ) .)
    ^               reduce using rule 76 (expr -> ID ( args ) .)
    &               reduce using rule 76 (expr -> ID ( args ) .)
    SHR             reduce using rule 76 (expr -> ID ( args ) .)
    SHL             reduce using rule 76 (expr -> ID ( args ) .)
    GREATER         reduce using rule 76 (expr -> ID ( args ) .)
    LESS            reduce using rule 76 (expr -> ID ( args ) .)
    OR              reduce using rule 76 (expr -> ID ( args ) .)
    AND             reduce using rule 76 (expr -> ID ( args ) .)
    GREATEREQ       reduce using rule 76 (expr -> ID ( args ) .)
    LESSEQ          reduce using rule 76 (expr -> ID ( args ) .)
    NOTEQ           reduce using rule 76 (expr -> ID ( args ) .)
    EQEQ            reduce using rule 76 (expr -> ID ( args ) .)
    ID              reduce using rule 76 (expr -> ID ( args ) .)
    ?               reduce using rule 76 (expr -> ID ( args ) .)
    LET             reduce using rule 76 (expr -> ID ( args ) .)
    PRINT           reduce using rule 76 (expr -> ID ( args ) .)
    RAW_INPUT       reduce using rule 76 (expr -> ID ( args ) .)
    {               reduce using rule 76 (expr -> ID ( args ) .)
    NIL             reduce using rule 76 (expr -> ID ( args ) .)
    FALSE           reduce using rule 76 (expr -> ID ( args ) .)
    TRUE            reduce using rule 76 (expr -> ID ( args ) .)
    STRING          reduce using rule 76 (expr -> ID ( args ) .)
    FLOAT           reduce using rule 76 (expr -> ID ( args ) .)
    INT             reduce using rule 76 (expr -> ID ( args ) .)
    (               reduce using rule 76 (expr -> ID ( args ) .)
    !               reduce using rule 76 (expr -> ID ( args ) .)
    ~               reduce using rule 76 (expr -> ID ( args ) .)
    TYPEOF          reduce using rule 76 (expr -> ID ( args ) .)
    LAMBDA          reduce using rule 76 (expr -> ID ( args ) .)
    DEC             reduce using rule 76 (expr -> ID ( args ) .)
    INC             reduce using rule 76 (expr -> ID ( args ) .)
    CLASS           reduce using rule 76 (expr -> ID ( args ) .)
    STRUCT          reduce using rule 76 (expr -> ID ( args ) .)
    IF              reduce using rule 76 (expr -> ID ( args ) .)
    FOR             reduce using rule 76 (expr -> ID ( args ) .)
    WHILE           reduce using rule 76 (expr -> ID ( args ) .)
    RETURN          reduce using rule 76 (expr -> ID ( args ) .)
    FN              reduce using rule 76 (expr -> ID ( args ) .)
    IMPORT          reduce using rule 76 (expr -> ID ( args ) .)
    [               reduce using rule 76 (expr -> ID ( args ) .)
    $end            reduce using rule 76 (expr -> ID ( args ) .)
    }               reduce using rule 76 (expr -> ID ( args ) .)
    ELSE            reduce using rule 76 (expr -> ID ( args ) .)
    ]               reduce using rule 76 (expr -> ID ( args ) .)
    ,               reduce using rule 76 (expr -> ID ( args ) .)
    )               reduce using rule 76 (expr -> ID ( args ) .)
    TO              reduce using rule 76 (expr -> ID ( args ) .)
    :               reduce using rule 76 (expr -> ID ( args ) .)


state 213

    (119) args -> args , . arg
    (120) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    arg                            shift and go to state 239
    expr                           shift and go to state 176
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 214

    (80) expr -> ID LEFTARROW { struct_init_exprs . }
    (81) struct_init_exprs -> struct_init_exprs . , expr
    }               shift and go to state 240
    ,               shift and go to state 241


state 215

    (82) struct_init_exprs -> expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    }               reduce using rule 82 (struct_init_exprs -> expr .)
    ,               reduce using rule 82 (struct_init_exprs -> expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 216

    (79) expr -> LAMBDA ( params ) . ARROW expr
    ARROW           shift and go to state 242


state 217

    (115) params -> params , . param
    (116) param -> . ID var_type
    ID              shift and go to state 181

    param                          shift and go to state 243

state 218

    (116) param -> ID var_type .
    )               reduce using rule 116 (param -> ID var_type .)
    ,               reduce using rule 116 (param -> ID var_type .)


state 219

    (19) class_definition -> CLASS ID { function_definitions . }
    (20) function_definitions -> function_definitions . function_definition
    (34) function_definition -> . FN ID ( params ) block
    }               shift and go to state 244
    FN              shift and go to state 46

    function_definition            shift and go to state 245

state 220

    (21) function_definitions -> function_definition .
    }               reduce using rule 21 (function_definitions -> function_definition .)
    FN              reduce using rule 21 (function_definitions -> function_definition .)


state 221

    (22) function_definitions -> empty .
    }               reduce using rule 22 (function_definitions -> empty .)
    FN              reduce using rule 22 (function_definitions -> empty .)


state 222

    (23) struct_definition -> STRUCT ID { struct_fields . } SEP
    (24) struct_fields -> struct_fields . struct_field
    (26) struct_field -> . LET ID : var_type SEP
    }               shift and go to state 246
    LET             shift and go to state 224

    struct_field                   shift and go to state 247

state 223

    (25) struct_fields -> struct_field .
    }               reduce using rule 25 (struct_fields -> struct_field .)
    LET             reduce using rule 25 (struct_fields -> struct_field .)


state 224

    (26) struct_field -> LET . ID : var_type SEP
    ID              shift and go to state 248


state 225

    (101) if_statement -> IF expr block ELSE . block
    (111) block -> . statement
    (112) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 189
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    expr                           shift and go to state 5
    block                          shift and go to state 249
    statement                      shift and go to state 188
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 226

    (55) expr -> expr - expr .
    (59) expr -> - expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for PERSENT resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for DIV resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for MUL resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for SUB resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for ADD resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for % resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for / resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for * resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for - resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for + resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for | resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for ^ resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for & resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for SHR resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for SHL resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for LESS resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for OR resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for AND resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for ID resolved using rule 59 (expr -> - expr .)
  ! reduce/reduce conflict for ? resolved using rule 59 (expr -> - expr .)
    {               reduce using rule 55 (expr -> expr - expr .)
    LET             reduce using rule 55 (expr -> expr - expr .)
    PRINT           reduce using rule 55 (expr -> expr - expr .)
    RAW_INPUT       reduce using rule 55 (expr -> expr - expr .)
    NIL             reduce using rule 55 (expr -> expr - expr .)
    FALSE           reduce using rule 55 (expr -> expr - expr .)
    TRUE            reduce using rule 55 (expr -> expr - expr .)
    STRING          reduce using rule 55 (expr -> expr - expr .)
    FLOAT           reduce using rule 55 (expr -> expr - expr .)
    INT             reduce using rule 55 (expr -> expr - expr .)
    (               reduce using rule 55 (expr -> expr - expr .)
    !               reduce using rule 55 (expr -> expr - expr .)
    ~               reduce using rule 55 (expr -> expr - expr .)
    TYPEOF          reduce using rule 55 (expr -> expr - expr .)
    LAMBDA          reduce using rule 55 (expr -> expr - expr .)
    DEC             reduce using rule 55 (expr -> expr - expr .)
    INC             reduce using rule 55 (expr -> expr - expr .)
    CLASS           reduce using rule 55 (expr -> expr - expr .)
    STRUCT          reduce using rule 55 (expr -> expr - expr .)
    IF              reduce using rule 55 (expr -> expr - expr .)
    FOR             reduce using rule 55 (expr -> expr - expr .)
    WHILE           reduce using rule 55 (expr -> expr - expr .)
    RETURN          reduce using rule 55 (expr -> expr - expr .)
    FN              reduce using rule 55 (expr -> expr - expr .)
    IMPORT          reduce using rule 55 (expr -> expr - expr .)
    [               reduce using rule 55 (expr -> expr - expr .)
    SEP             reduce using rule 59 (expr -> - expr .)
    PERSENT         reduce using rule 59 (expr -> - expr .)
    DIV             reduce using rule 59 (expr -> - expr .)
    MUL             reduce using rule 59 (expr -> - expr .)
    SUB             reduce using rule 59 (expr -> - expr .)
    ADD             reduce using rule 59 (expr -> - expr .)
    %               reduce using rule 59 (expr -> - expr .)
    /               reduce using rule 59 (expr -> - expr .)
    *               reduce using rule 59 (expr -> - expr .)
    -               reduce using rule 59 (expr -> - expr .)
    +               reduce using rule 59 (expr -> - expr .)
    |               reduce using rule 59 (expr -> - expr .)
    ^               reduce using rule 59 (expr -> - expr .)
    &               reduce using rule 59 (expr -> - expr .)
    SHR             reduce using rule 59 (expr -> - expr .)
    SHL             reduce using rule 59 (expr -> - expr .)
    GREATER         reduce using rule 59 (expr -> - expr .)
    LESS            reduce using rule 59 (expr -> - expr .)
    OR              reduce using rule 59 (expr -> - expr .)
    AND             reduce using rule 59 (expr -> - expr .)
    GREATEREQ       reduce using rule 59 (expr -> - expr .)
    LESSEQ          reduce using rule 59 (expr -> - expr .)
    NOTEQ           reduce using rule 59 (expr -> - expr .)
    EQEQ            reduce using rule 59 (expr -> - expr .)
    ID              reduce using rule 59 (expr -> - expr .)
    ?               reduce using rule 59 (expr -> - expr .)


state 227

    (56) expr -> expr + expr .
    (58) expr -> + expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! reduce/reduce conflict for PERSENT resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for DIV resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for MUL resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for SUB resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for ADD resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for % resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for / resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for * resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for - resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for + resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for | resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for ^ resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for & resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for SHR resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for SHL resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for GREATER resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for LESS resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for OR resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for AND resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for EQEQ resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for ID resolved using rule 58 (expr -> + expr .)
  ! reduce/reduce conflict for ? resolved using rule 58 (expr -> + expr .)
    {               reduce using rule 56 (expr -> expr + expr .)
    LET             reduce using rule 56 (expr -> expr + expr .)
    PRINT           reduce using rule 56 (expr -> expr + expr .)
    RAW_INPUT       reduce using rule 56 (expr -> expr + expr .)
    NIL             reduce using rule 56 (expr -> expr + expr .)
    FALSE           reduce using rule 56 (expr -> expr + expr .)
    TRUE            reduce using rule 56 (expr -> expr + expr .)
    STRING          reduce using rule 56 (expr -> expr + expr .)
    FLOAT           reduce using rule 56 (expr -> expr + expr .)
    INT             reduce using rule 56 (expr -> expr + expr .)
    (               reduce using rule 56 (expr -> expr + expr .)
    !               reduce using rule 56 (expr -> expr + expr .)
    ~               reduce using rule 56 (expr -> expr + expr .)
    TYPEOF          reduce using rule 56 (expr -> expr + expr .)
    LAMBDA          reduce using rule 56 (expr -> expr + expr .)
    DEC             reduce using rule 56 (expr -> expr + expr .)
    INC             reduce using rule 56 (expr -> expr + expr .)
    CLASS           reduce using rule 56 (expr -> expr + expr .)
    STRUCT          reduce using rule 56 (expr -> expr + expr .)
    IF              reduce using rule 56 (expr -> expr + expr .)
    FOR             reduce using rule 56 (expr -> expr + expr .)
    WHILE           reduce using rule 56 (expr -> expr + expr .)
    RETURN          reduce using rule 56 (expr -> expr + expr .)
    FN              reduce using rule 56 (expr -> expr + expr .)
    IMPORT          reduce using rule 56 (expr -> expr + expr .)
    [               reduce using rule 56 (expr -> expr + expr .)
    SEP             reduce using rule 58 (expr -> + expr .)
    PERSENT         reduce using rule 58 (expr -> + expr .)
    DIV             reduce using rule 58 (expr -> + expr .)
    MUL             reduce using rule 58 (expr -> + expr .)
    SUB             reduce using rule 58 (expr -> + expr .)
    ADD             reduce using rule 58 (expr -> + expr .)
    %               reduce using rule 58 (expr -> + expr .)
    /               reduce using rule 58 (expr -> + expr .)
    *               reduce using rule 58 (expr -> + expr .)
    -               reduce using rule 58 (expr -> + expr .)
    +               reduce using rule 58 (expr -> + expr .)
    |               reduce using rule 58 (expr -> + expr .)
    ^               reduce using rule 58 (expr -> + expr .)
    &               reduce using rule 58 (expr -> + expr .)
    SHR             reduce using rule 58 (expr -> + expr .)
    SHL             reduce using rule 58 (expr -> + expr .)
    GREATER         reduce using rule 58 (expr -> + expr .)
    LESS            reduce using rule 58 (expr -> + expr .)
    OR              reduce using rule 58 (expr -> + expr .)
    AND             reduce using rule 58 (expr -> + expr .)
    GREATEREQ       reduce using rule 58 (expr -> + expr .)
    LESSEQ          reduce using rule 58 (expr -> + expr .)
    NOTEQ           reduce using rule 58 (expr -> + expr .)
    EQEQ            reduce using rule 58 (expr -> + expr .)
    ID              reduce using rule 58 (expr -> + expr .)
    ?               reduce using rule 58 (expr -> + expr .)


state 228

    (74) expr -> expr ID ( . args )
    (76) expr -> ID ( . args )
    (117) args -> . empty
    (118) args -> . arg
    (119) args -> . args , arg
    (110) empty -> .
    (120) arg -> . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    )               reduce using rule 110 (empty -> .)
    ,               reduce using rule 110 (empty -> .)
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 176
    args                           shift and go to state 250
    empty                          shift and go to state 174
    arg                            shift and go to state 175
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 229

    (112) block -> { program . }
    }               shift and go to state 251


state 230

    (1) program -> empty .
    (123) member_list -> empty .
  ! reduce/reduce conflict for } resolved using rule 1 (program -> empty .)
    }               reduce using rule 1 (program -> empty .)
    ,               reduce using rule 123 (member_list -> empty .)


state 231

    (124) member -> STRING . : expr
    (43) expr -> STRING .
    :               shift and go to state 168
    SEP             reduce using rule 43 (expr -> STRING .)
    PERSENT         reduce using rule 43 (expr -> STRING .)
    DIV             reduce using rule 43 (expr -> STRING .)
    MUL             reduce using rule 43 (expr -> STRING .)
    SUB             reduce using rule 43 (expr -> STRING .)
    ADD             reduce using rule 43 (expr -> STRING .)
    %               reduce using rule 43 (expr -> STRING .)
    /               reduce using rule 43 (expr -> STRING .)
    *               reduce using rule 43 (expr -> STRING .)
    -               reduce using rule 43 (expr -> STRING .)
    +               reduce using rule 43 (expr -> STRING .)
    |               reduce using rule 43 (expr -> STRING .)
    ^               reduce using rule 43 (expr -> STRING .)
    &               reduce using rule 43 (expr -> STRING .)
    SHR             reduce using rule 43 (expr -> STRING .)
    SHL             reduce using rule 43 (expr -> STRING .)
    GREATER         reduce using rule 43 (expr -> STRING .)
    LESS            reduce using rule 43 (expr -> STRING .)
    OR              reduce using rule 43 (expr -> STRING .)
    AND             reduce using rule 43 (expr -> STRING .)
    GREATEREQ       reduce using rule 43 (expr -> STRING .)
    LESSEQ          reduce using rule 43 (expr -> STRING .)
    NOTEQ           reduce using rule 43 (expr -> STRING .)
    EQEQ            reduce using rule 43 (expr -> STRING .)
    ID              reduce using rule 43 (expr -> STRING .)
    ?               reduce using rule 43 (expr -> STRING .)


state 232

    (103) for_statement -> FOR expr TO expr . block
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    (111) block -> . statement
    (112) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 185
    +               shift and go to state 186
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 187
    ?               shift and go to state 74
    {               shift and go to state 189
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    ~               shift and go to state 34
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    expr                           shift and go to state 5
    block                          shift and go to state 252
    statement                      shift and go to state 188
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 233

    (34) function_definition -> FN ID ( params . ) block
    (115) params -> params . , param
    )               shift and go to state 253
    ,               shift and go to state 217


state 234

    (74) expr -> expr ID ( args ) .
    SEP             reduce using rule 74 (expr -> expr ID ( args ) .)
    PERSENT         reduce using rule 74 (expr -> expr ID ( args ) .)
    DIV             reduce using rule 74 (expr -> expr ID ( args ) .)
    MUL             reduce using rule 74 (expr -> expr ID ( args ) .)
    SUB             reduce using rule 74 (expr -> expr ID ( args ) .)
    ADD             reduce using rule 74 (expr -> expr ID ( args ) .)
    %               reduce using rule 74 (expr -> expr ID ( args ) .)
    /               reduce using rule 74 (expr -> expr ID ( args ) .)
    *               reduce using rule 74 (expr -> expr ID ( args ) .)
    -               reduce using rule 74 (expr -> expr ID ( args ) .)
    +               reduce using rule 74 (expr -> expr ID ( args ) .)
    |               reduce using rule 74 (expr -> expr ID ( args ) .)
    ^               reduce using rule 74 (expr -> expr ID ( args ) .)
    &               reduce using rule 74 (expr -> expr ID ( args ) .)
    SHR             reduce using rule 74 (expr -> expr ID ( args ) .)
    SHL             reduce using rule 74 (expr -> expr ID ( args ) .)
    GREATER         reduce using rule 74 (expr -> expr ID ( args ) .)
    LESS            reduce using rule 74 (expr -> expr ID ( args ) .)
    OR              reduce using rule 74 (expr -> expr ID ( args ) .)
    AND             reduce using rule 74 (expr -> expr ID ( args ) .)
    GREATEREQ       reduce using rule 74 (expr -> expr ID ( args ) .)
    LESSEQ          reduce using rule 74 (expr -> expr ID ( args ) .)
    NOTEQ           reduce using rule 74 (expr -> expr ID ( args ) .)
    EQEQ            reduce using rule 74 (expr -> expr ID ( args ) .)
    ID              reduce using rule 74 (expr -> expr ID ( args ) .)
    ?               reduce using rule 74 (expr -> expr ID ( args ) .)
    LET             reduce using rule 74 (expr -> expr ID ( args ) .)
    PRINT           reduce using rule 74 (expr -> expr ID ( args ) .)
    RAW_INPUT       reduce using rule 74 (expr -> expr ID ( args ) .)
    {               reduce using rule 74 (expr -> expr ID ( args ) .)
    NIL             reduce using rule 74 (expr -> expr ID ( args ) .)
    FALSE           reduce using rule 74 (expr -> expr ID ( args ) .)
    TRUE            reduce using rule 74 (expr -> expr ID ( args ) .)
    STRING          reduce using rule 74 (expr -> expr ID ( args ) .)
    FLOAT           reduce using rule 74 (expr -> expr ID ( args ) .)
    INT             reduce using rule 74 (expr -> expr ID ( args ) .)
    (               reduce using rule 74 (expr -> expr ID ( args ) .)
    !               reduce using rule 74 (expr -> expr ID ( args ) .)
    ~               reduce using rule 74 (expr -> expr ID ( args ) .)
    TYPEOF          reduce using rule 74 (expr -> expr ID ( args ) .)
    LAMBDA          reduce using rule 74 (expr -> expr ID ( args ) .)
    DEC             reduce using rule 74 (expr -> expr ID ( args ) .)
    INC             reduce using rule 74 (expr -> expr ID ( args ) .)
    CLASS           reduce using rule 74 (expr -> expr ID ( args ) .)
    STRUCT          reduce using rule 74 (expr -> expr ID ( args ) .)
    IF              reduce using rule 74 (expr -> expr ID ( args ) .)
    FOR             reduce using rule 74 (expr -> expr ID ( args ) .)
    WHILE           reduce using rule 74 (expr -> expr ID ( args ) .)
    RETURN          reduce using rule 74 (expr -> expr ID ( args ) .)
    FN              reduce using rule 74 (expr -> expr ID ( args ) .)
    IMPORT          reduce using rule 74 (expr -> expr ID ( args ) .)
    [               reduce using rule 74 (expr -> expr ID ( args ) .)
    $end            reduce using rule 74 (expr -> expr ID ( args ) .)
    }               reduce using rule 74 (expr -> expr ID ( args ) .)
    ELSE            reduce using rule 74 (expr -> expr ID ( args ) .)
    ]               reduce using rule 74 (expr -> expr ID ( args ) .)
    ,               reduce using rule 74 (expr -> expr ID ( args ) .)
    )               reduce using rule 74 (expr -> expr ID ( args ) .)
    TO              reduce using rule 74 (expr -> expr ID ( args ) .)
    :               reduce using rule 74 (expr -> expr ID ( args ) .)


state 235

    (77) expr -> expr ? expr : expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 77 (expr -> expr ? expr : expr .)
    LET             reduce using rule 77 (expr -> expr ? expr : expr .)
    PRINT           reduce using rule 77 (expr -> expr ? expr : expr .)
    RAW_INPUT       reduce using rule 77 (expr -> expr ? expr : expr .)
    {               reduce using rule 77 (expr -> expr ? expr : expr .)
    NIL             reduce using rule 77 (expr -> expr ? expr : expr .)
    FALSE           reduce using rule 77 (expr -> expr ? expr : expr .)
    TRUE            reduce using rule 77 (expr -> expr ? expr : expr .)
    STRING          reduce using rule 77 (expr -> expr ? expr : expr .)
    FLOAT           reduce using rule 77 (expr -> expr ? expr : expr .)
    INT             reduce using rule 77 (expr -> expr ? expr : expr .)
    (               reduce using rule 77 (expr -> expr ? expr : expr .)
    !               reduce using rule 77 (expr -> expr ? expr : expr .)
    ~               reduce using rule 77 (expr -> expr ? expr : expr .)
    TYPEOF          reduce using rule 77 (expr -> expr ? expr : expr .)
    LAMBDA          reduce using rule 77 (expr -> expr ? expr : expr .)
    DEC             reduce using rule 77 (expr -> expr ? expr : expr .)
    INC             reduce using rule 77 (expr -> expr ? expr : expr .)
    CLASS           reduce using rule 77 (expr -> expr ? expr : expr .)
    STRUCT          reduce using rule 77 (expr -> expr ? expr : expr .)
    IF              reduce using rule 77 (expr -> expr ? expr : expr .)
    FOR             reduce using rule 77 (expr -> expr ? expr : expr .)
    WHILE           reduce using rule 77 (expr -> expr ? expr : expr .)
    RETURN          reduce using rule 77 (expr -> expr ? expr : expr .)
    FN              reduce using rule 77 (expr -> expr ? expr : expr .)
    IMPORT          reduce using rule 77 (expr -> expr ? expr : expr .)
    [               reduce using rule 77 (expr -> expr ? expr : expr .)
    $end            reduce using rule 77 (expr -> expr ? expr : expr .)
    }               reduce using rule 77 (expr -> expr ? expr : expr .)
    ELSE            reduce using rule 77 (expr -> expr ? expr : expr .)
    ]               reduce using rule 77 (expr -> expr ? expr : expr .)
    ,               reduce using rule 77 (expr -> expr ? expr : expr .)
    )               reduce using rule 77 (expr -> expr ? expr : expr .)
    TO              reduce using rule 77 (expr -> expr ? expr : expr .)
    :               reduce using rule 77 (expr -> expr ? expr : expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 236

    (7) statement -> LET var : var_type SEP .
    LET             reduce using rule 7 (statement -> LET var : var_type SEP .)
    PRINT           reduce using rule 7 (statement -> LET var : var_type SEP .)
    RAW_INPUT       reduce using rule 7 (statement -> LET var : var_type SEP .)
    {               reduce using rule 7 (statement -> LET var : var_type SEP .)
    NIL             reduce using rule 7 (statement -> LET var : var_type SEP .)
    FALSE           reduce using rule 7 (statement -> LET var : var_type SEP .)
    TRUE            reduce using rule 7 (statement -> LET var : var_type SEP .)
    STRING          reduce using rule 7 (statement -> LET var : var_type SEP .)
    FLOAT           reduce using rule 7 (statement -> LET var : var_type SEP .)
    INT             reduce using rule 7 (statement -> LET var : var_type SEP .)
    (               reduce using rule 7 (statement -> LET var : var_type SEP .)
    !               reduce using rule 7 (statement -> LET var : var_type SEP .)
    +               reduce using rule 7 (statement -> LET var : var_type SEP .)
    -               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ~               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ID              reduce using rule 7 (statement -> LET var : var_type SEP .)
    TYPEOF          reduce using rule 7 (statement -> LET var : var_type SEP .)
    LAMBDA          reduce using rule 7 (statement -> LET var : var_type SEP .)
    DEC             reduce using rule 7 (statement -> LET var : var_type SEP .)
    INC             reduce using rule 7 (statement -> LET var : var_type SEP .)
    CLASS           reduce using rule 7 (statement -> LET var : var_type SEP .)
    STRUCT          reduce using rule 7 (statement -> LET var : var_type SEP .)
    IF              reduce using rule 7 (statement -> LET var : var_type SEP .)
    FOR             reduce using rule 7 (statement -> LET var : var_type SEP .)
    WHILE           reduce using rule 7 (statement -> LET var : var_type SEP .)
    RETURN          reduce using rule 7 (statement -> LET var : var_type SEP .)
    FN              reduce using rule 7 (statement -> LET var : var_type SEP .)
    IMPORT          reduce using rule 7 (statement -> LET var : var_type SEP .)
    [               reduce using rule 7 (statement -> LET var : var_type SEP .)
    $end            reduce using rule 7 (statement -> LET var : var_type SEP .)
    }               reduce using rule 7 (statement -> LET var : var_type SEP .)
    ELSE            reduce using rule 7 (statement -> LET var : var_type SEP .)


state 237

    (108) var -> var [ expr ] .
    :               reduce using rule 108 (var -> var [ expr ] .)
    ASSIGN          reduce using rule 108 (var -> var [ expr ] .)
    [               reduce using rule 108 (var -> var [ expr ] .)
    SEP             reduce using rule 108 (var -> var [ expr ] .)


state 238

    (75) expr -> ID DOUBLECOLON ID ( args . )
    (119) args -> args . , arg
    )               shift and go to state 254
    ,               shift and go to state 213


state 239

    (119) args -> args , arg .
    )               reduce using rule 119 (args -> args , arg .)
    ,               reduce using rule 119 (args -> args , arg .)


state 240

    (80) expr -> ID LEFTARROW { struct_init_exprs } .
    SEP             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    PERSENT         reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    DIV             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    MUL             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    SUB             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ADD             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    %               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    /               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    *               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    -               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    +               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    |               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ^               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    &               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    SHR             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    SHL             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    GREATER         reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LESS            reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    OR              reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    AND             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    GREATEREQ       reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LESSEQ          reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    NOTEQ           reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    EQEQ            reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ID              reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ?               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LET             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    PRINT           reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    RAW_INPUT       reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    {               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    NIL             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FALSE           reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    TRUE            reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    STRING          reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FLOAT           reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    INT             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    (               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    !               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ~               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    TYPEOF          reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    LAMBDA          reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    DEC             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    INC             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    CLASS           reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    STRUCT          reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    IF              reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FOR             reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    WHILE           reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    RETURN          reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    FN              reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    IMPORT          reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    [               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    $end            reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    }               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ELSE            reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ]               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    ,               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    )               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    TO              reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)
    :               reduce using rule 80 (expr -> ID LEFTARROW { struct_init_exprs } .)


state 241

    (81) struct_init_exprs -> struct_init_exprs , . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 255
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 242

    (79) expr -> LAMBDA ( params ) ARROW . expr
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 21
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    [               shift and go to state 23

    expr                           shift and go to state 256
    getter                         shift and go to state 20
    var                            shift and go to state 92
    list_val                       shift and go to state 24

state 243

    (115) params -> params , param .
    )               reduce using rule 115 (params -> params , param .)
    ,               reduce using rule 115 (params -> params , param .)


state 244

    (19) class_definition -> CLASS ID { function_definitions } .
    LET             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    PRINT           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    RAW_INPUT       reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    {               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    NIL             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FALSE           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    TRUE            reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    STRING          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FLOAT           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    INT             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    (               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    !               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    +               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    -               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    ~               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    ID              reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    TYPEOF          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    LAMBDA          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    DEC             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    INC             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    CLASS           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    STRUCT          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    IF              reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FOR             reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    WHILE           reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    RETURN          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    FN              reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    IMPORT          reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    [               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    $end            reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    }               reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)
    ELSE            reduce using rule 19 (class_definition -> CLASS ID { function_definitions } .)


state 245

    (20) function_definitions -> function_definitions function_definition .
    }               reduce using rule 20 (function_definitions -> function_definitions function_definition .)
    FN              reduce using rule 20 (function_definitions -> function_definitions function_definition .)


state 246

    (23) struct_definition -> STRUCT ID { struct_fields } . SEP
    SEP             shift and go to state 257


state 247

    (24) struct_fields -> struct_fields struct_field .
    }               reduce using rule 24 (struct_fields -> struct_fields struct_field .)
    LET             reduce using rule 24 (struct_fields -> struct_fields struct_field .)


state 248

    (26) struct_field -> LET ID . : var_type SEP
    :               shift and go to state 258


state 249

    (101) if_statement -> IF expr block ELSE block .
    LET             reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    PRINT           reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    RAW_INPUT       reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    {               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    NIL             reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    FALSE           reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    TRUE            reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    STRING          reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    FLOAT           reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    INT             reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    (               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    !               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    +               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    -               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    ~               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    ID              reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    TYPEOF          reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    LAMBDA          reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    DEC             reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    INC             reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    CLASS           reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    STRUCT          reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    IF              reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    FOR             reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    WHILE           reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    RETURN          reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    FN              reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    IMPORT          reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    [               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    $end            reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    }               reduce using rule 101 (if_statement -> IF expr block ELSE block .)
    ELSE            reduce using rule 101 (if_statement -> IF expr block ELSE block .)


state 250

    (74) expr -> expr ID ( args . )
    (76) expr -> ID ( args . )
    (119) args -> args . , arg
    )               shift and go to state 259
    ,               shift and go to state 213


state 251

    (112) block -> { program } .
    ELSE            reduce using rule 112 (block -> { program } .)
    LET             reduce using rule 112 (block -> { program } .)
    PRINT           reduce using rule 112 (block -> { program } .)
    RAW_INPUT       reduce using rule 112 (block -> { program } .)
    {               reduce using rule 112 (block -> { program } .)
    NIL             reduce using rule 112 (block -> { program } .)
    FALSE           reduce using rule 112 (block -> { program } .)
    TRUE            reduce using rule 112 (block -> { program } .)
    STRING          reduce using rule 112 (block -> { program } .)
    FLOAT           reduce using rule 112 (block -> { program } .)
    INT             reduce using rule 112 (block -> { program } .)
    (               reduce using rule 112 (block -> { program } .)
    !               reduce using rule 112 (block -> { program } .)
    +               reduce using rule 112 (block -> { program } .)
    -               reduce using rule 112 (block -> { program } .)
    ~               reduce using rule 112 (block -> { program } .)
    ID              reduce using rule 112 (block -> { program } .)
    TYPEOF          reduce using rule 112 (block -> { program } .)
    LAMBDA          reduce using rule 112 (block -> { program } .)
    DEC             reduce using rule 112 (block -> { program } .)
    INC             reduce using rule 112 (block -> { program } .)
    CLASS           reduce using rule 112 (block -> { program } .)
    STRUCT          reduce using rule 112 (block -> { program } .)
    IF              reduce using rule 112 (block -> { program } .)
    FOR             reduce using rule 112 (block -> { program } .)
    WHILE           reduce using rule 112 (block -> { program } .)
    RETURN          reduce using rule 112 (block -> { program } .)
    FN              reduce using rule 112 (block -> { program } .)
    IMPORT          reduce using rule 112 (block -> { program } .)
    [               reduce using rule 112 (block -> { program } .)
    $end            reduce using rule 112 (block -> { program } .)
    }               reduce using rule 112 (block -> { program } .)


state 252

    (103) for_statement -> FOR expr TO expr block .
    LET             reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    PRINT           reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    RAW_INPUT       reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    {               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    NIL             reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    FALSE           reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    TRUE            reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    STRING          reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    FLOAT           reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    INT             reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    (               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    !               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    +               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    -               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    ~               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    ID              reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    TYPEOF          reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    LAMBDA          reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    DEC             reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    INC             reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    CLASS           reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    STRUCT          reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    IF              reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    FOR             reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    WHILE           reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    RETURN          reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    FN              reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    IMPORT          reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    [               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    $end            reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    }               reduce using rule 103 (for_statement -> FOR expr TO expr block .)
    ELSE            reduce using rule 103 (for_statement -> FOR expr TO expr block .)


state 253

    (34) function_definition -> FN ID ( params ) . block
    (111) block -> . statement
    (112) block -> . { program }
    (5) statement -> . expr SEP
    (6) statement -> . var_assign SEP
    (7) statement -> . LET var : var_type SEP
    (8) statement -> . PRINT expr
    (9) statement -> . var_define SEP
    (10) statement -> . class_definition
    (11) statement -> . struct_definition
    (12) statement -> . if_statement
    (13) statement -> . for_statement
    (14) statement -> . while_statement
    (15) statement -> . return_statement
    (16) statement -> . function_definition
    (17) statement -> . import_statement
    (18) statement -> . RAW_INPUT
    (35) expr -> . getter
    (36) expr -> . { member_list }
    (37) expr -> . NIL
    (38) expr -> . var
    (39) expr -> . var [ expr ]
    (40) expr -> . list_val
    (41) expr -> . FALSE
    (42) expr -> . TRUE
    (43) expr -> . STRING
    (44) expr -> . FLOAT
    (45) expr -> . INT
    (46) expr -> . ( expr )
    (47) expr -> . expr PERSENT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr MUL expr
    (50) expr -> . expr SUB expr
    (51) expr -> . expr ADD expr
    (52) expr -> . expr % expr
    (53) expr -> . expr / expr
    (54) expr -> . expr * expr
    (55) expr -> . expr - expr
    (56) expr -> . expr + expr
    (57) expr -> . ! expr
    (58) expr -> . + expr
    (59) expr -> . - expr
    (60) expr -> . ~ expr
    (61) expr -> . expr | expr
    (62) expr -> . expr ^ expr
    (63) expr -> . expr & expr
    (64) expr -> . expr SHR expr
    (65) expr -> . expr SHL expr
    (66) expr -> . expr GREATER expr
    (67) expr -> . expr LESS expr
    (68) expr -> . expr OR expr
    (69) expr -> . expr AND expr
    (70) expr -> . expr GREATEREQ expr
    (71) expr -> . expr LESSEQ expr
    (72) expr -> . expr NOTEQ expr
    (73) expr -> . expr EQEQ expr
    (74) expr -> . expr ID ( args )
    (75) expr -> . ID DOUBLECOLON ID ( args )
    (76) expr -> . ID ( args )
    (77) expr -> . expr ? expr : expr
    (78) expr -> . TYPEOF expr
    (79) expr -> . LAMBDA ( params ) ARROW expr
    (80) expr -> . ID LEFTARROW { struct_init_exprs }
    (86) var_assign -> . DEC var
    (87) var_assign -> . INC var
    (88) var_assign -> . var SHRASGN expr
    (89) var_assign -> . var SHLASGN expr
    (90) var_assign -> . var XORASGN expr
    (91) var_assign -> . var ORASGN expr
    (92) var_assign -> . var ANDASGN expr
    (93) var_assign -> . var MODULOASGN expr
    (94) var_assign -> . var SLASHASGN expr
    (95) var_assign -> . var STARASGN expr
    (96) var_assign -> . var MINUSASGN expr
    (97) var_assign -> . var PLUSASGN expr
    (98) var_assign -> . var ASSIGN RAW_INPUT
    (99) var_assign -> . var ASSIGN expr
    (83) var_define -> . LET getter ASSIGN expr
    (84) var_define -> . LET var ASSIGN expr
    (19) class_definition -> . CLASS ID { function_definitions }
    (23) struct_definition -> . STRUCT ID { struct_fields } SEP
    (100) if_statement -> . IF expr block
    (101) if_statement -> . IF expr block ELSE block
    (103) for_statement -> . FOR expr TO expr block
    (102) while_statement -> . WHILE expr block
    (85) return_statement -> . RETURN expr SEP
    (34) function_definition -> . FN ID ( params ) block
    (33) import_statement -> . IMPORT STRING SEP
    (125) getter -> . ID
    (126) getter -> . getter . ID
    (108) var -> . var [ expr ]
    (109) var -> . ID
    (104) list_val -> . [ exprs ]
    {               shift and go to state 189
    LET             shift and go to state 7
    PRINT           shift and go to state 9
    RAW_INPUT       shift and go to state 19
    NIL             shift and go to state 22
    FALSE           shift and go to state 25
    TRUE            shift and go to state 26
    STRING          shift and go to state 27
    FLOAT           shift and go to state 28
    INT             shift and go to state 29
    (               shift and go to state 30
    !               shift and go to state 33
    +               shift and go to state 32
    -               shift and go to state 31
    ~               shift and go to state 34
    ID              shift and go to state 35
    TYPEOF          shift and go to state 36
    LAMBDA          shift and go to state 37
    DEC             shift and go to state 38
    INC             shift and go to state 39
    CLASS           shift and go to state 40
    STRUCT          shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43
    WHILE           shift and go to state 44
    RETURN          shift and go to state 45
    FN              shift and go to state 46
    IMPORT          shift and go to state 47
    [               shift and go to state 23

    block                          shift and go to state 260
    statement                      shift and go to state 188
    expr                           shift and go to state 5
    var_assign                     shift and go to state 6
    var                            shift and go to state 8
    var_define                     shift and go to state 10
    class_definition               shift and go to state 11
    struct_definition              shift and go to state 12
    if_statement                   shift and go to state 13
    for_statement                  shift and go to state 14
    while_statement                shift and go to state 15
    return_statement               shift and go to state 16
    function_definition            shift and go to state 17
    import_statement               shift and go to state 18
    getter                         shift and go to state 20
    list_val                       shift and go to state 24

state 254

    (75) expr -> ID DOUBLECOLON ID ( args ) .
    SEP             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    PERSENT         reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    DIV             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    MUL             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    SUB             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ADD             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    %               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    /               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    *               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    -               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    +               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    |               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ^               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    &               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    SHR             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    SHL             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    GREATER         reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    LESS            reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    OR              reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    AND             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    GREATEREQ       reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    LESSEQ          reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    NOTEQ           reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    EQEQ            reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ID              reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ?               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    LET             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    PRINT           reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    RAW_INPUT       reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    {               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    NIL             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    FALSE           reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    TRUE            reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    STRING          reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    FLOAT           reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    INT             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    (               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    !               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ~               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    TYPEOF          reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    LAMBDA          reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    DEC             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    INC             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    CLASS           reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    STRUCT          reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    IF              reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    FOR             reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    WHILE           reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    RETURN          reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    FN              reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    IMPORT          reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    [               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    $end            reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    }               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ELSE            reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ]               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    ,               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    )               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    TO              reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)
    :               reduce using rule 75 (expr -> ID DOUBLECOLON ID ( args ) .)


state 255

    (81) struct_init_exprs -> struct_init_exprs , expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
    }               reduce using rule 81 (struct_init_exprs -> struct_init_exprs , expr .)
    ,               reduce using rule 81 (struct_init_exprs -> struct_init_exprs , expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 256

    (79) expr -> LAMBDA ( params ) ARROW expr .
    (47) expr -> expr . PERSENT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . MUL expr
    (50) expr -> expr . SUB expr
    (51) expr -> expr . ADD expr
    (52) expr -> expr . % expr
    (53) expr -> expr . / expr
    (54) expr -> expr . * expr
    (55) expr -> expr . - expr
    (56) expr -> expr . + expr
    (61) expr -> expr . | expr
    (62) expr -> expr . ^ expr
    (63) expr -> expr . & expr
    (64) expr -> expr . SHR expr
    (65) expr -> expr . SHL expr
    (66) expr -> expr . GREATER expr
    (67) expr -> expr . LESS expr
    (68) expr -> expr . OR expr
    (69) expr -> expr . AND expr
    (70) expr -> expr . GREATEREQ expr
    (71) expr -> expr . LESSEQ expr
    (72) expr -> expr . NOTEQ expr
    (73) expr -> expr . EQEQ expr
    (74) expr -> expr . ID ( args )
    (77) expr -> expr . ? expr : expr
  ! shift/reduce conflict for PERSENT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for | resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for SHR resolved as shift
  ! shift/reduce conflict for SHL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for NOTEQ resolved as shift
  ! shift/reduce conflict for EQEQ resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ? resolved as shift
    SEP             reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    LET             reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    PRINT           reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    RAW_INPUT       reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    {               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    NIL             reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    FALSE           reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    TRUE            reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    STRING          reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    FLOAT           reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    INT             reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    (               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    !               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    ~               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    TYPEOF          reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    LAMBDA          reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    DEC             reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    INC             reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    CLASS           reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    STRUCT          reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    IF              reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    FOR             reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    WHILE           reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    RETURN          reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    FN              reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    IMPORT          reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    [               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    $end            reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    }               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    ELSE            reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    ]               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    ,               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    )               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    TO              reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    :               reduce using rule 79 (expr -> LAMBDA ( params ) ARROW expr .)
    PERSENT         shift and go to state 50
    DIV             shift and go to state 51
    MUL             shift and go to state 52
    SUB             shift and go to state 53
    ADD             shift and go to state 54
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57
    -               shift and go to state 58
    +               shift and go to state 59
    |               shift and go to state 60
    ^               shift and go to state 61
    &               shift and go to state 62
    SHR             shift and go to state 63
    SHL             shift and go to state 64
    GREATER         shift and go to state 65
    LESS            shift and go to state 66
    OR              shift and go to state 67
    AND             shift and go to state 68
    GREATEREQ       shift and go to state 69
    LESSEQ          shift and go to state 70
    NOTEQ           shift and go to state 71
    EQEQ            shift and go to state 72
    ID              shift and go to state 73
    ?               shift and go to state 74


state 257

    (23) struct_definition -> STRUCT ID { struct_fields } SEP .
    LET             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    PRINT           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    RAW_INPUT       reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    {               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    NIL             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FALSE           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    TRUE            reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    STRING          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FLOAT           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    INT             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    (               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    !               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    +               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    -               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ~               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ID              reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    TYPEOF          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    LAMBDA          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    DEC             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    INC             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    CLASS           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    STRUCT          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    IF              reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FOR             reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    WHILE           reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    RETURN          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    FN              reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    IMPORT          reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    [               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    $end            reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    }               reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)
    ELSE            reduce using rule 23 (struct_definition -> STRUCT ID { struct_fields } SEP .)


state 258

    (26) struct_field -> LET ID : . var_type SEP
    (27) var_type -> . DICT_TYPE
    (28) var_type -> . LIST_TYPE
    (29) var_type -> . BOOL_TYPE
    (30) var_type -> . STRING_TYPE
    (31) var_type -> . FLOAT_TYPE
    (32) var_type -> . INT_TYPE
    DICT_TYPE       shift and go to state 198
    LIST_TYPE       shift and go to state 199
    BOOL_TYPE       shift and go to state 200
    STRING_TYPE     shift and go to state 201
    FLOAT_TYPE      shift and go to state 202
    INT_TYPE        shift and go to state 203

    var_type                       shift and go to state 261

state 259

    (74) expr -> expr ID ( args ) .
    (76) expr -> ID ( args ) .
  ! reduce/reduce conflict for PERSENT resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for DIV resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for MUL resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for SUB resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for ADD resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for % resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for / resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for * resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for - resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for + resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for | resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for ^ resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for & resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for SHR resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for SHL resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for GREATER resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for LESS resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for OR resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for AND resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for GREATEREQ resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for LESSEQ resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for NOTEQ resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for EQEQ resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for ID resolved using rule 76 (expr -> ID ( args ) .)
  ! reduce/reduce conflict for ? resolved using rule 76 (expr -> ID ( args ) .)
    {               reduce using rule 74 (expr -> expr ID ( args ) .)
    LET             reduce using rule 74 (expr -> expr ID ( args ) .)
    PRINT           reduce using rule 74 (expr -> expr ID ( args ) .)
    RAW_INPUT       reduce using rule 74 (expr -> expr ID ( args ) .)
    NIL             reduce using rule 74 (expr -> expr ID ( args ) .)
    FALSE           reduce using rule 74 (expr -> expr ID ( args ) .)
    TRUE            reduce using rule 74 (expr -> expr ID ( args ) .)
    STRING          reduce using rule 74 (expr -> expr ID ( args ) .)
    FLOAT           reduce using rule 74 (expr -> expr ID ( args ) .)
    INT             reduce using rule 74 (expr -> expr ID ( args ) .)
    (               reduce using rule 74 (expr -> expr ID ( args ) .)
    !               reduce using rule 74 (expr -> expr ID ( args ) .)
    ~               reduce using rule 74 (expr -> expr ID ( args ) .)
    TYPEOF          reduce using rule 74 (expr -> expr ID ( args ) .)
    LAMBDA          reduce using rule 74 (expr -> expr ID ( args ) .)
    DEC             reduce using rule 74 (expr -> expr ID ( args ) .)
    INC             reduce using rule 74 (expr -> expr ID ( args ) .)
    CLASS           reduce using rule 74 (expr -> expr ID ( args ) .)
    STRUCT          reduce using rule 74 (expr -> expr ID ( args ) .)
    IF              reduce using rule 74 (expr -> expr ID ( args ) .)
    FOR             reduce using rule 74 (expr -> expr ID ( args ) .)
    WHILE           reduce using rule 74 (expr -> expr ID ( args ) .)
    RETURN          reduce using rule 74 (expr -> expr ID ( args ) .)
    FN              reduce using rule 74 (expr -> expr ID ( args ) .)
    IMPORT          reduce using rule 74 (expr -> expr ID ( args ) .)
    [               reduce using rule 74 (expr -> expr ID ( args ) .)
    SEP             reduce using rule 76 (expr -> ID ( args ) .)
    PERSENT         reduce using rule 76 (expr -> ID ( args ) .)
    DIV             reduce using rule 76 (expr -> ID ( args ) .)
    MUL             reduce using rule 76 (expr -> ID ( args ) .)
    SUB             reduce using rule 76 (expr -> ID ( args ) .)
    ADD             reduce using rule 76 (expr -> ID ( args ) .)
    %               reduce using rule 76 (expr -> ID ( args ) .)
    /               reduce using rule 76 (expr -> ID ( args ) .)
    *               reduce using rule 76 (expr -> ID ( args ) .)
    -               reduce using rule 76 (expr -> ID ( args ) .)
    +               reduce using rule 76 (expr -> ID ( args ) .)
    |               reduce using rule 76 (expr -> ID ( args ) .)
    ^               reduce using rule 76 (expr -> ID ( args ) .)
    &               reduce using rule 76 (expr -> ID ( args ) .)
    SHR             reduce using rule 76 (expr -> ID ( args ) .)
    SHL             reduce using rule 76 (expr -> ID ( args ) .)
    GREATER         reduce using rule 76 (expr -> ID ( args ) .)
    LESS            reduce using rule 76 (expr -> ID ( args ) .)
    OR              reduce using rule 76 (expr -> ID ( args ) .)
    AND             reduce using rule 76 (expr -> ID ( args ) .)
    GREATEREQ       reduce using rule 76 (expr -> ID ( args ) .)
    LESSEQ          reduce using rule 76 (expr -> ID ( args ) .)
    NOTEQ           reduce using rule 76 (expr -> ID ( args ) .)
    EQEQ            reduce using rule 76 (expr -> ID ( args ) .)
    ID              reduce using rule 76 (expr -> ID ( args ) .)
    ?               reduce using rule 76 (expr -> ID ( args ) .)


state 260

    (34) function_definition -> FN ID ( params ) block .
    LET             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    PRINT           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    RAW_INPUT       reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    {               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    NIL             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FALSE           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    TRUE            reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    STRING          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FLOAT           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    INT             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    (               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    !               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    +               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    -               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    ~               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    ID              reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    TYPEOF          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    LAMBDA          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    DEC             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    INC             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    CLASS           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    STRUCT          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    IF              reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FOR             reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    WHILE           reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    RETURN          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    FN              reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    IMPORT          reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    [               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    $end            reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    }               reduce using rule 34 (function_definition -> FN ID ( params ) block .)
    ELSE            reduce using rule 34 (function_definition -> FN ID ( params ) block .)


state 261

    (26) struct_field -> LET ID : var_type . SEP
    SEP             shift and go to state 262


state 262

    (26) struct_field -> LET ID : var_type SEP .
    }               reduce using rule 26 (struct_field -> LET ID : var_type SEP .)
    LET             reduce using rule 26 (struct_field -> LET ID : var_type SEP .)


Conflicts:

shift/reduce conflict for ( in state 35 resolved as shift
shift/reduce conflict for ( in state 35 resolved as shift
shift/reduce conflict for - in state 91 resolved as shift
shift/reduce conflict for + in state 91 resolved as shift
shift/reduce conflict for ID in state 91 resolved as shift
shift/reduce conflict for [ in state 92 resolved as shift
shift/reduce conflict for PERSENT in state 110 resolved as shift
shift/reduce conflict for DIV in state 110 resolved as shift
shift/reduce conflict for MUL in state 110 resolved as shift
shift/reduce conflict for SUB in state 110 resolved as shift
shift/reduce conflict for ADD in state 110 resolved as shift
shift/reduce conflict for % in state 110 resolved as shift
shift/reduce conflict for / in state 110 resolved as shift
shift/reduce conflict for * in state 110 resolved as shift
shift/reduce conflict for - in state 110 resolved as shift
shift/reduce conflict for + in state 110 resolved as shift
shift/reduce conflict for | in state 110 resolved as shift
shift/reduce conflict for ^ in state 110 resolved as shift
shift/reduce conflict for & in state 110 resolved as shift
shift/reduce conflict for SHR in state 110 resolved as shift
shift/reduce conflict for SHL in state 110 resolved as shift
shift/reduce conflict for GREATER in state 110 resolved as shift
shift/reduce conflict for LESS in state 110 resolved as shift
shift/reduce conflict for OR in state 110 resolved as shift
shift/reduce conflict for AND in state 110 resolved as shift
shift/reduce conflict for GREATEREQ in state 110 resolved as shift
shift/reduce conflict for LESSEQ in state 110 resolved as shift
shift/reduce conflict for NOTEQ in state 110 resolved as shift
shift/reduce conflict for EQEQ in state 110 resolved as shift
shift/reduce conflict for ID in state 110 resolved as shift
shift/reduce conflict for ? in state 110 resolved as shift
shift/reduce conflict for PERSENT in state 123 resolved as shift
shift/reduce conflict for DIV in state 123 resolved as shift
shift/reduce conflict for MUL in state 123 resolved as shift
shift/reduce conflict for SUB in state 123 resolved as shift
shift/reduce conflict for ADD in state 123 resolved as shift
shift/reduce conflict for % in state 123 resolved as shift
shift/reduce conflict for / in state 123 resolved as shift
shift/reduce conflict for * in state 123 resolved as shift
shift/reduce conflict for - in state 123 resolved as shift
shift/reduce conflict for + in state 123 resolved as shift
shift/reduce conflict for | in state 123 resolved as shift
shift/reduce conflict for ^ in state 123 resolved as shift
shift/reduce conflict for & in state 123 resolved as shift
shift/reduce conflict for SHR in state 123 resolved as shift
shift/reduce conflict for SHL in state 123 resolved as shift
shift/reduce conflict for GREATER in state 123 resolved as shift
shift/reduce conflict for LESS in state 123 resolved as shift
shift/reduce conflict for OR in state 123 resolved as shift
shift/reduce conflict for AND in state 123 resolved as shift
shift/reduce conflict for GREATEREQ in state 123 resolved as shift
shift/reduce conflict for LESSEQ in state 123 resolved as shift
shift/reduce conflict for NOTEQ in state 123 resolved as shift
shift/reduce conflict for EQEQ in state 123 resolved as shift
shift/reduce conflict for ID in state 123 resolved as shift
shift/reduce conflict for ? in state 123 resolved as shift
shift/reduce conflict for PERSENT in state 124 resolved as shift
shift/reduce conflict for DIV in state 124 resolved as shift
shift/reduce conflict for MUL in state 124 resolved as shift
shift/reduce conflict for SUB in state 124 resolved as shift
shift/reduce conflict for ADD in state 124 resolved as shift
shift/reduce conflict for % in state 124 resolved as shift
shift/reduce conflict for / in state 124 resolved as shift
shift/reduce conflict for * in state 124 resolved as shift
shift/reduce conflict for - in state 124 resolved as shift
shift/reduce conflict for + in state 124 resolved as shift
shift/reduce conflict for | in state 124 resolved as shift
shift/reduce conflict for ^ in state 124 resolved as shift
shift/reduce conflict for & in state 124 resolved as shift
shift/reduce conflict for SHR in state 124 resolved as shift
shift/reduce conflict for SHL in state 124 resolved as shift
shift/reduce conflict for GREATER in state 124 resolved as shift
shift/reduce conflict for LESS in state 124 resolved as shift
shift/reduce conflict for OR in state 124 resolved as shift
shift/reduce conflict for AND in state 124 resolved as shift
shift/reduce conflict for GREATEREQ in state 124 resolved as shift
shift/reduce conflict for LESSEQ in state 124 resolved as shift
shift/reduce conflict for NOTEQ in state 124 resolved as shift
shift/reduce conflict for EQEQ in state 124 resolved as shift
shift/reduce conflict for ID in state 124 resolved as shift
shift/reduce conflict for ? in state 124 resolved as shift
shift/reduce conflict for PERSENT in state 125 resolved as shift
shift/reduce conflict for DIV in state 125 resolved as shift
shift/reduce conflict for MUL in state 125 resolved as shift
shift/reduce conflict for SUB in state 125 resolved as shift
shift/reduce conflict for ADD in state 125 resolved as shift
shift/reduce conflict for % in state 125 resolved as shift
shift/reduce conflict for / in state 125 resolved as shift
shift/reduce conflict for * in state 125 resolved as shift
shift/reduce conflict for - in state 125 resolved as shift
shift/reduce conflict for + in state 125 resolved as shift
shift/reduce conflict for | in state 125 resolved as shift
shift/reduce conflict for ^ in state 125 resolved as shift
shift/reduce conflict for & in state 125 resolved as shift
shift/reduce conflict for SHR in state 125 resolved as shift
shift/reduce conflict for SHL in state 125 resolved as shift
shift/reduce conflict for GREATER in state 125 resolved as shift
shift/reduce conflict for LESS in state 125 resolved as shift
shift/reduce conflict for OR in state 125 resolved as shift
shift/reduce conflict for AND in state 125 resolved as shift
shift/reduce conflict for GREATEREQ in state 125 resolved as shift
shift/reduce conflict for LESSEQ in state 125 resolved as shift
shift/reduce conflict for NOTEQ in state 125 resolved as shift
shift/reduce conflict for EQEQ in state 125 resolved as shift
shift/reduce conflict for ID in state 125 resolved as shift
shift/reduce conflict for ? in state 125 resolved as shift
shift/reduce conflict for PERSENT in state 126 resolved as shift
shift/reduce conflict for DIV in state 126 resolved as shift
shift/reduce conflict for MUL in state 126 resolved as shift
shift/reduce conflict for SUB in state 126 resolved as shift
shift/reduce conflict for ADD in state 126 resolved as shift
shift/reduce conflict for % in state 126 resolved as shift
shift/reduce conflict for / in state 126 resolved as shift
shift/reduce conflict for * in state 126 resolved as shift
shift/reduce conflict for - in state 126 resolved as shift
shift/reduce conflict for + in state 126 resolved as shift
shift/reduce conflict for | in state 126 resolved as shift
shift/reduce conflict for ^ in state 126 resolved as shift
shift/reduce conflict for & in state 126 resolved as shift
shift/reduce conflict for SHR in state 126 resolved as shift
shift/reduce conflict for SHL in state 126 resolved as shift
shift/reduce conflict for GREATER in state 126 resolved as shift
shift/reduce conflict for LESS in state 126 resolved as shift
shift/reduce conflict for OR in state 126 resolved as shift
shift/reduce conflict for AND in state 126 resolved as shift
shift/reduce conflict for GREATEREQ in state 126 resolved as shift
shift/reduce conflict for LESSEQ in state 126 resolved as shift
shift/reduce conflict for NOTEQ in state 126 resolved as shift
shift/reduce conflict for EQEQ in state 126 resolved as shift
shift/reduce conflict for ID in state 126 resolved as shift
shift/reduce conflict for ? in state 126 resolved as shift
shift/reduce conflict for PERSENT in state 127 resolved as shift
shift/reduce conflict for DIV in state 127 resolved as shift
shift/reduce conflict for MUL in state 127 resolved as shift
shift/reduce conflict for SUB in state 127 resolved as shift
shift/reduce conflict for ADD in state 127 resolved as shift
shift/reduce conflict for % in state 127 resolved as shift
shift/reduce conflict for / in state 127 resolved as shift
shift/reduce conflict for * in state 127 resolved as shift
shift/reduce conflict for - in state 127 resolved as shift
shift/reduce conflict for + in state 127 resolved as shift
shift/reduce conflict for | in state 127 resolved as shift
shift/reduce conflict for ^ in state 127 resolved as shift
shift/reduce conflict for & in state 127 resolved as shift
shift/reduce conflict for SHR in state 127 resolved as shift
shift/reduce conflict for SHL in state 127 resolved as shift
shift/reduce conflict for GREATER in state 127 resolved as shift
shift/reduce conflict for LESS in state 127 resolved as shift
shift/reduce conflict for OR in state 127 resolved as shift
shift/reduce conflict for AND in state 127 resolved as shift
shift/reduce conflict for GREATEREQ in state 127 resolved as shift
shift/reduce conflict for LESSEQ in state 127 resolved as shift
shift/reduce conflict for NOTEQ in state 127 resolved as shift
shift/reduce conflict for EQEQ in state 127 resolved as shift
shift/reduce conflict for ID in state 127 resolved as shift
shift/reduce conflict for ? in state 127 resolved as shift
shift/reduce conflict for FN in state 182 resolved as shift
shift/reduce conflict for ELSE in state 184 resolved as shift
shift/reduce conflict for PERSENT in state 235 resolved as shift
shift/reduce conflict for DIV in state 235 resolved as shift
shift/reduce conflict for MUL in state 235 resolved as shift
shift/reduce conflict for SUB in state 235 resolved as shift
shift/reduce conflict for ADD in state 235 resolved as shift
shift/reduce conflict for % in state 235 resolved as shift
shift/reduce conflict for / in state 235 resolved as shift
shift/reduce conflict for * in state 235 resolved as shift
shift/reduce conflict for - in state 235 resolved as shift
shift/reduce conflict for + in state 235 resolved as shift
shift/reduce conflict for | in state 235 resolved as shift
shift/reduce conflict for ^ in state 235 resolved as shift
shift/reduce conflict for & in state 235 resolved as shift
shift/reduce conflict for SHR in state 235 resolved as shift
shift/reduce conflict for SHL in state 235 resolved as shift
shift/reduce conflict for GREATER in state 235 resolved as shift
shift/reduce conflict for LESS in state 235 resolved as shift
shift/reduce conflict for OR in state 235 resolved as shift
shift/reduce conflict for AND in state 235 resolved as shift
shift/reduce conflict for GREATEREQ in state 235 resolved as shift
shift/reduce conflict for LESSEQ in state 235 resolved as shift
shift/reduce conflict for NOTEQ in state 235 resolved as shift
shift/reduce conflict for EQEQ in state 235 resolved as shift
shift/reduce conflict for ID in state 235 resolved as shift
shift/reduce conflict for ? in state 235 resolved as shift
shift/reduce conflict for PERSENT in state 256 resolved as shift
shift/reduce conflict for DIV in state 256 resolved as shift
shift/reduce conflict for MUL in state 256 resolved as shift
shift/reduce conflict for SUB in state 256 resolved as shift
shift/reduce conflict for ADD in state 256 resolved as shift
shift/reduce conflict for % in state 256 resolved as shift
shift/reduce conflict for / in state 256 resolved as shift
shift/reduce conflict for * in state 256 resolved as shift
shift/reduce conflict for - in state 256 resolved as shift
shift/reduce conflict for + in state 256 resolved as shift
shift/reduce conflict for | in state 256 resolved as shift
shift/reduce conflict for ^ in state 256 resolved as shift
shift/reduce conflict for & in state 256 resolved as shift
shift/reduce conflict for SHR in state 256 resolved as shift
shift/reduce conflict for SHL in state 256 resolved as shift
shift/reduce conflict for GREATER in state 256 resolved as shift
shift/reduce conflict for LESS in state 256 resolved as shift
shift/reduce conflict for OR in state 256 resolved as shift
shift/reduce conflict for AND in state 256 resolved as shift
shift/reduce conflict for GREATEREQ in state 256 resolved as shift
shift/reduce conflict for LESSEQ in state 256 resolved as shift
shift/reduce conflict for NOTEQ in state 256 resolved as shift
shift/reduce conflict for EQEQ in state 256 resolved as shift
shift/reduce conflict for ID in state 256 resolved as shift
shift/reduce conflict for ? in state 256 resolved as shift
reduce/reduce conflict in state 35 resolved using rule var -> ID
rejected rule (getter -> ID) in state 35
reduce/reduce conflict in state 78 resolved using rule var -> ID
rejected rule (getter -> ID) in state 78
reduce/reduce conflict in state 187 resolved using rule var -> ID
rejected rule (getter -> ID) in state 187
reduce/reduce conflict in state 207 resolved using rule expr -> var [ expr ]
rejected rule (var -> var [ expr ]) in state 207
reduce/reduce conflict in state 226 resolved using rule expr -> - expr  [precedence=right, level=12]
rejected rule (expr -> expr - expr  [precedence=left, level=10]) in state 226
reduce/reduce conflict in state 227 resolved using rule expr -> + expr  [precedence=right, level=12]
rejected rule (expr -> expr + expr  [precedence=left, level=10]) in state 227
reduce/reduce conflict in state 230 resolved using rule program -> empty
rejected rule (member_list -> empty) in state 230
reduce/reduce conflict in state 259 resolved using rule expr -> ID ( args )
rejected rule (expr -> expr ID ( args )) in state 259